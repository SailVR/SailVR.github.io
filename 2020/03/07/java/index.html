<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>java | Blog</title><meta name="description" content="java面试常见知识点"><meta name="keywords" content="java"><meta name="author" content="Sail"><meta name="copyright" content="Sail"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java"><meta name="twitter:description" content="java面试常见知识点"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="java"><meta property="og:url" content="https://sailvr.github.io/2020/03/07/java/"><meta property="og:site_name" content="Blog"><meta property="og:description" content="java面试常见知识点"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://sailvr.github.io/2020/03/07/java/"><link rel="prev" title="interview" href="https://sailvr.github.io/2020/05/25/interview/"><link rel="next" title="Hello World" href="https://sailvr.github.io/2020/03/07/hello-world/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#计算机网络"><span class="toc_mobile_items-text">计算机网络</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#GET请求和POST请求的区别"><span class="toc_mobile_items-text">GET请求和POST请求的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Cookie和Session的区别"><span class="toc_mobile_items-text">Cookie和Session的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HTTP与HTTPS的区别"><span class="toc_mobile_items-text">HTTP与HTTPS的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Socket相关"><span class="toc_mobile_items-text">Socket相关</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数据库"><span class="toc_mobile_items-text">数据库</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引模块"><span class="toc_mobile_items-text">索引模块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#B-Tree"><span class="toc_mobile_items-text">B Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#B-Tree-1"><span class="toc_mobile_items-text">B+ Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Hash索引"><span class="toc_mobile_items-text">Hash索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#BitMap"><span class="toc_mobile_items-text">BitMap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#密集索引和稀疏索引的区别"><span class="toc_mobile_items-text">密集索引和稀疏索引的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引调优"><span class="toc_mobile_items-text">索引调优</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Redis"><span class="toc_mobile_items-text">Redis</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#缓存中间件——Memcache和Redis的区别"><span class="toc_mobile_items-text">缓存中间件——Memcache和Redis的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么Redis这么快"><span class="toc_mobile_items-text">为什么Redis这么快</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多路I-O复用模型"><span class="toc_mobile_items-text">多路I&#x2F;O复用模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Redis的数据类型"><span class="toc_mobile_items-text">Redis的数据类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#从海量Key里查询出某一固定前缀的Key"><span class="toc_mobile_items-text">从海量Key里查询出某一固定前缀的Key</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何通过Redis实现分布式锁"><span class="toc_mobile_items-text">如何通过Redis实现分布式锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何实现异步队列"><span class="toc_mobile_items-text">如何实现异步队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Redis如何做持久化"><span class="toc_mobile_items-text">Redis如何做持久化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#RDB（快照持久化）：保存某个时间点的全量数据快照"><span class="toc_mobile_items-text">RDB（快照持久化）：保存某个时间点的全量数据快照</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#AOF（Append-Only-File）持久化：保存写状态"><span class="toc_mobile_items-text">AOF（Append-Only-File）持久化：保存写状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#RDB-AOF混合持久化方式"><span class="toc_mobile_items-text">RDB-AOF混合持久化方式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Pipeline及主从同步"><span class="toc_mobile_items-text">Pipeline及主从同步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Redis集群"><span class="toc_mobile_items-text">Redis集群</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Linux"><span class="toc_mobile_items-text">Linux</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux的体系结构"><span class="toc_mobile_items-text">Linux的体系结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#查找特定的文件"><span class="toc_mobile_items-text">查找特定的文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#检索文件的内容"><span class="toc_mobile_items-text">检索文件的内容</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#对文件内容做统计"><span class="toc_mobile_items-text">对文件内容做统计</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#批量替换文件内容"><span class="toc_mobile_items-text">批量替换文件内容</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#JVM"><span class="toc_mobile_items-text">JVM</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#谈谈你对java的理解"><span class="toc_mobile_items-text">谈谈你对java的理解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Compile-Once-Run-Anywhere如何实现"><span class="toc_mobile_items-text">Compile Once ,Run Anywhere如何实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JVM如何加载-class文件"><span class="toc_mobile_items-text">JVM如何加载.class文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是反射"><span class="toc_mobile_items-text">什么是反射</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#谈谈ClassLoader"><span class="toc_mobile_items-text">谈谈ClassLoader</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#谈谈类加载器的双亲委派机制"><span class="toc_mobile_items-text">谈谈类加载器的双亲委派机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类的加载方式"><span class="toc_mobile_items-text">类的加载方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java的内存模型"><span class="toc_mobile_items-text">Java的内存模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#常考题解析"><span class="toc_mobile_items-text">常考题解析</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java垃圾回收机制"><span class="toc_mobile_items-text">Java垃圾回收机制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#垃圾回收之标记算法"><span class="toc_mobile_items-text">垃圾回收之标记算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#谈谈你了解的垃圾回收算法"><span class="toc_mobile_items-text">谈谈你了解的垃圾回收算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分带收集算法（Generational-Collector）"><span class="toc_mobile_items-text">分带收集算法（Generational Collector）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#常见垃圾收集器"><span class="toc_mobile_items-text">常见垃圾收集器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#GC相关的面试题"><span class="toc_mobile_items-text">GC相关的面试题</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#java多线程与并发"><span class="toc_mobile_items-text">java多线程与并发</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#start和run方法的区别"><span class="toc_mobile_items-text">start和run方法的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Thread和Runnable是什么关系"><span class="toc_mobile_items-text">Thread和Runnable是什么关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何给run-方法传参"><span class="toc_mobile_items-text">如何给run()方法传参</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何实现处理线程的返回值"><span class="toc_mobile_items-text">如何实现处理线程的返回值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程的状态"><span class="toc_mobile_items-text">线程的状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sleep和wait的区别"><span class="toc_mobile_items-text">sleep和wait的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#yield函数"><span class="toc_mobile_items-text">yield函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#interrupt函数"><span class="toc_mobile_items-text">interrupt函数</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#java多线程与并发原理"><span class="toc_mobile_items-text">java多线程与并发原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized"><span class="toc_mobile_items-text">synchronized</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#synchronized和ReentrantLock的区别"><span class="toc_mobile_items-text">synchronized和ReentrantLock的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是Java内存模型中的happens-before"><span class="toc_mobile_items-text">什么是Java内存模型中的happens-before</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JMM如何解决可见性问题"><span class="toc_mobile_items-text">JMM如何解决可见性问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CAS（Compare-and-Swap）"><span class="toc_mobile_items-text">CAS（Compare and Swap）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java线程池"><span class="toc_mobile_items-text">Java线程池</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#常见类库与技巧"><span class="toc_mobile_items-text">常见类库与技巧</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java异常"><span class="toc_mobile_items-text">Java异常</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java异常处理机制"><span class="toc_mobile_items-text">Java异常处理机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java集合框架"><span class="toc_mobile_items-text">Java集合框架</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HashMap"><span class="toc_mobile_items-text">HashMap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#J-U-C知识点梳理"><span class="toc_mobile_items-text">J.U.C知识点梳理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java的IO机制"><span class="toc_mobile_items-text">Java的IO机制</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Spring"><span class="toc_mobile_items-text">Spring</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#IOC-（Inversion-of-control）-控制反转"><span class="toc_mobile_items-text">IOC （Inversion of control） 控制反转</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Spring-IOC"><span class="toc_mobile_items-text">Spring IOC</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#getBean方法解析"><span class="toc_mobile_items-text">getBean方法解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Spring-AOP"><span class="toc_mobile_items-text">Spring AOP</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Spring-AOP的原理"><span class="toc_mobile_items-text">Spring AOP的原理</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机网络"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET请求和POST请求的区别"><span class="toc-text">GET请求和POST请求的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie和Session的区别"><span class="toc-text">Cookie和Session的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP与HTTPS的区别"><span class="toc-text">HTTP与HTTPS的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket相关"><span class="toc-text">Socket相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引模块"><span class="toc-text">索引模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree"><span class="toc-text">B Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-1"><span class="toc-text">B+ Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash索引"><span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BitMap"><span class="toc-text">BitMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#密集索引和稀疏索引的区别"><span class="toc-text">密集索引和稀疏索引的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引调优"><span class="toc-text">索引调优</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存中间件——Memcache和Redis的区别"><span class="toc-text">缓存中间件——Memcache和Redis的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么Redis这么快"><span class="toc-text">为什么Redis这么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路I-O复用模型"><span class="toc-text">多路I&#x2F;O复用模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的数据类型"><span class="toc-text">Redis的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从海量Key里查询出某一固定前缀的Key"><span class="toc-text">从海量Key里查询出某一固定前缀的Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何通过Redis实现分布式锁"><span class="toc-text">如何通过Redis实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现异步队列"><span class="toc-text">如何实现异步队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis如何做持久化"><span class="toc-text">Redis如何做持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB（快照持久化）：保存某个时间点的全量数据快照"><span class="toc-text">RDB（快照持久化）：保存某个时间点的全量数据快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF（Append-Only-File）持久化：保存写状态"><span class="toc-text">AOF（Append-Only-File）持久化：保存写状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-AOF混合持久化方式"><span class="toc-text">RDB-AOF混合持久化方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipeline及主从同步"><span class="toc-text">Pipeline及主从同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis集群"><span class="toc-text">Redis集群</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux的体系结构"><span class="toc-text">Linux的体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找特定的文件"><span class="toc-text">查找特定的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检索文件的内容"><span class="toc-text">检索文件的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对文件内容做统计"><span class="toc-text">对文件内容做统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批量替换文件内容"><span class="toc-text">批量替换文件内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你对java的理解"><span class="toc-text">谈谈你对java的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compile-Once-Run-Anywhere如何实现"><span class="toc-text">Compile Once ,Run Anywhere如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM如何加载-class文件"><span class="toc-text">JVM如何加载.class文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是反射"><span class="toc-text">什么是反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈ClassLoader"><span class="toc-text">谈谈ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈类加载器的双亲委派机制"><span class="toc-text">谈谈类加载器的双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载方式"><span class="toc-text">类的加载方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的内存模型"><span class="toc-text">Java的内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常考题解析"><span class="toc-text">常考题解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java垃圾回收机制"><span class="toc-text">Java垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收之标记算法"><span class="toc-text">垃圾回收之标记算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你了解的垃圾回收算法"><span class="toc-text">谈谈你了解的垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分带收集算法（Generational-Collector）"><span class="toc-text">分带收集算法（Generational Collector）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见垃圾收集器"><span class="toc-text">常见垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC相关的面试题"><span class="toc-text">GC相关的面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java多线程与并发"><span class="toc-text">java多线程与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#start和run方法的区别"><span class="toc-text">start和run方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread和Runnable是什么关系"><span class="toc-text">Thread和Runnable是什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何给run-方法传参"><span class="toc-text">如何给run()方法传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现处理线程的返回值"><span class="toc-text">如何实现处理线程的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态"><span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep和wait的区别"><span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield函数"><span class="toc-text">yield函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt函数"><span class="toc-text">interrupt函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java多线程与并发原理"><span class="toc-text">java多线程与并发原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和ReentrantLock的区别"><span class="toc-text">synchronized和ReentrantLock的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Java内存模型中的happens-before"><span class="toc-text">什么是Java内存模型中的happens-before</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM如何解决可见性问题"><span class="toc-text">JMM如何解决可见性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS（Compare-and-Swap）"><span class="toc-text">CAS（Compare and Swap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java线程池"><span class="toc-text">Java线程池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常见类库与技巧"><span class="toc-text">常见类库与技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java异常"><span class="toc-text">Java异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java异常处理机制"><span class="toc-text">Java异常处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java集合框架"><span class="toc-text">Java集合框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C知识点梳理"><span class="toc-text">J.U.C知识点梳理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的IO机制"><span class="toc-text">Java的IO机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC-（Inversion-of-control）-控制反转"><span class="toc-text">IOC （Inversion of control） 控制反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-IOC"><span class="toc-text">Spring IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getBean方法解析"><span class="toc-text">getBean方法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP"><span class="toc-text">Spring AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP的原理"><span class="toc-text">Spring AOP的原理</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">java</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-03-07<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-04-15</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h3><p>Http报文层面：GET将请求信息放在URL中，POST放在报文体中</p>
<p>数据库层面：GET符合幂等性和安全性，POST不符合</p>
<p>其他层面：GET可以被缓存、被存储，而POST不行</p>
<h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><p>Cookie是由服务器发给客户端的特殊消息，以文本的形式存放在客户端。客户端发送请求的时候，会把Cookie回发。服务器接收到后，会解析Cookie生成与客户端相对应的内容。</p>
<p>Session：服务器端的机制，在服务器上保存的信息、解析客户端请求并操作session id，按需保存状态信息。</p>
<p>Session的实现：1使用Cookie实现 2使用URL回写来实现</p>
<p>区别:Cookie数据存放在客户的浏览器上，Session数据放在服务器上。Session相对于Cookie更安全。若减轻服务器负担，应当使用Cookie</p>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><p>SSL（Security Sockets Layer 安全套阶层）</p>
<p>为网络通信提供安全及数据完整性的一种安全协议</p>
<p>是操作系统对外的API，SSL3.0后更名为TLS</p>
<p>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p>
<p><strong>加密的方式</strong> </p>
<p>对称加密：加密和解密都使用同一个密钥</p>
<p>非对称加密：加密使用的密钥和解密使用的密钥是不相同的</p>
<p><strong>HTTPS数据传输流程</strong></p>
<p>浏览器将支持的加密算法信息发送给服务器</p>
<p>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</p>
<p>浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器</p>
<p>服务器使用私钥解密信息，验证哈希，加密相应信息回发浏览器</p>
<p>浏览器解密响应信息，并对消息进行验真，之后进行加密交互数据</p>
<p><strong>区别</strong></p>
<p>HTTPS需要到CA申请证书，HTTP不需要</p>
<p>HTTPS密文传输，HTTP明文传输</p>
<p>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</p>
<p>HTTPS = HTTP+加密+认证+完整性保护，较HTTP安全</p>
<p><strong>HTTPS真的很安全吗？</strong></p>
<p>浏览器默认填充http://，请求需要进行跳转，有被劫持的风险</p>
<p>可以使用HSTS（HTTP Strict Transport Security）优化</p>
<h3 id="Socket相关"><a href="#Socket相关" class="headerlink" title="Socket相关"></a>Socket相关</h3><p><strong>Socket简介</strong></p>
<p>Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h3><ul>
<li>二叉查找树</li>
<li>B-树</li>
<li>B+树</li>
<li>Hash结构</li>
</ul>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h3><ul>
<li>根节点至少包括俩个孩子</li>
<li>树中每个节点最多含有m个孩子（m&gt;=2）</li>
<li>除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子</li>
<li>所有叶子节点都在同一层</li>
<li>假设每个非终端节点中包含有n个关键字信息，其中</li>
<li><ul>
<li>Ki（i=1,2….n）为关键字，且关键字按顺序升序排序K(i-1)&lt;Ki</li>
<li>关键字的个数n必须满足：ceil(m/2)-1&lt;=n&lt;=m-1</li>
<li>非叶子节点的指针：P[1],P[2],…P[M]；其中P[1]只想关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其中P[i]指向关键字属于(K[i-1],K[i])的子树</li>
</ul>
</li>
</ul>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+ Tree"></a>B+ Tree</h3><p>B+树定义基本与B树相同，除了</p>
<ul>
<li>非叶子节点的子树指针与关键字个数相同</li>
<li>非叶子节点的子树指针P[i]，只想关键字值(K[i],K[i+1])的子树</li>
<li>非叶子节点仅用来索引，数据都保存在叶子节点中</li>
<li>所有叶子节点均有一个链指针指向下一个叶子节点</li>
</ul>
<p>B+ Tree更适合用来做存储索引</p>
<ul>
<li>B+树的磁盘读写代价更低</li>
<li>B+树的查询效率更加稳定</li>
<li>B+树更有利于对数据库的扫描</li>
</ul>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>缺点</p>
<ul>
<li>仅仅能满足“=”，“IN”，不能使用范围查询</li>
<li>无法被用来避免数据的排序操作</li>
<li>不能利用部分索引键查询</li>
<li>不能避免表扫描</li>
<li>遇到大量Hash值相等的情况后性能并不一定就会比B Tree高</li>
</ul>
<h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<p>32位机器上的自然数一共有4294967296个，如果用一个bit来存放一个整数，1代表存在，0代表不存在，那么把全部自然数存储在内存只要4294967296 / (8 * 1024 * 1024) = 512MB（8bit = 一个字节），而这些自然数存放在文件中，一行一个数字，需要20G的容量。可见，bitmap算法节约了非常多的空间。</p>
<h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><ul>
<li>密集索引文件中的每个搜索码值都对应一个索引值</li>
<li>稀疏索引文件只为索引码的某些值建立索引项</li>
</ul>
<p>InnoDB</p>
<ul>
<li>若一个主键被定义，该主键则作为密集索引</li>
<li>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引</li>
<li>若不满足以上条件，innoDB内部会生成一个隐藏主键（密集索引）</li>
<li>若主键索引存储相关键位和其对应的主键值，包含俩次查找</li>
</ul>
<h3 id="索引调优"><a href="#索引调优" class="headerlink" title="索引调优"></a>索引调优</h3><ul>
<li>如何定位并优化慢查询Sql？</li>
<li><ul>
<li>根本慢日志定位慢查询sql</li>
<li>使用explain等工具分析sql</li>
<li>修改sql或者尽量让sql走索引</li>
</ul>
</li>
<li>联合索引的最左前缀匹配原则的成因</li>
<li><ul>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
</li>
<li>索引建立越多越好吗？</li>
<li><ul>
<li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引意味着也需要更多的空间</li>
</ul>
</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="缓存中间件——Memcache和Redis的区别"><a href="#缓存中间件——Memcache和Redis的区别" class="headerlink" title="缓存中间件——Memcache和Redis的区别"></a>缓存中间件——Memcache和Redis的区别</h3><p>Memcache：代码层类似Hash</p>
<ul>
<li>支持简单数据类型</li>
<li>不支持数据持久化存储</li>
<li>不支持主从</li>
<li>不支持分片</li>
</ul>
<p>Redis</p>
<ul>
<li>数据类型丰富</li>
<li>支持数据磁盘持久化存储</li>
<li>支持主从</li>
<li>支持分片</li>
</ul>
<h3 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h3><ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高</li>
<li>数据结构简单，对数据操作也简单</li>
<li>采用单线程，单线程也能处理高并发请求，想多核也可启动多实例</li>
<li>使用多路I/O复用类型，非阻塞IO</li>
</ul>
<h3 id="多路I-O复用模型"><a href="#多路I-O复用模型" class="headerlink" title="多路I/O复用模型"></a>多路I/O复用模型</h3><p>Redis采用的I/O多路复用函数：epoll/kqueue/evport/select?</p>
<ul>
<li>因地制宜</li>
<li>优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现</li>
<li>以时间复杂度为O(n)的select作为保底</li>
<li>基于react设计模式监听I/O事件</li>
</ul>
<h3 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h3><p>供用户使用的数据类型</p>
<ul>
<li>String：最基本的数据类型，二进制安全</li>
<li>Hash：String元素组成的字典，适合用于存储对象</li>
<li>List：列表，按照String元素插入顺序排序</li>
<li>Set：String元素组成的无序结合，通过哈希表实现，不允许重复</li>
<li>Sorted Set：通过分数来为集合中的成员进行从小到大的排序</li>
<li>用于计数的HyperLogLog，用于支持存储地理位置信息的Geo</li>
</ul>
<h3 id="从海量Key里查询出某一固定前缀的Key"><a href="#从海量Key里查询出某一固定前缀的Key" class="headerlink" title="从海量Key里查询出某一固定前缀的Key"></a>从海量Key里查询出某一固定前缀的Key</h3><p>KEYS pattern：查找所有符合给定模式pattern的key</p>
<ul>
<li>KEYS指令一次性返回所有匹配的key</li>
<li>键的数量过大使服务卡顿</li>
</ul>
<p>从海量Key里查询出某一固定前缀的Key</p>
<ul>
<li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</li>
<li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</li>
<li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li>
<li>一次返回的数量不可控，只能是大概率符合count参数</li>
</ul>
<h3 id="如何通过Redis实现分布式锁"><a href="#如何通过Redis实现分布式锁" class="headerlink" title="如何通过Redis实现分布式锁"></a>如何通过Redis实现分布式锁</h3><p>分布式锁需要解决的问题</p>
<ul>
<li>互斥性</li>
<li>安全性</li>
<li>死锁</li>
<li>容错</li>
</ul>
<p>SETNX key value：如果key不存在，则创建并赋值</p>
<ul>
<li>时间复杂度 O(1)</li>
<li>返回值：设置成功，返回1；设置失败，则返回0</li>
</ul>
<p>如何解决SETNX长期有效的问题</p>
<ul>
<li>EXPIRE key seconds</li>
<li><ul>
<li>设置key的生存时间，当key过期时（生存时间为0），会被自动删除</li>
<li>缺点：原子性得不到满足</li>
</ul>
</li>
<li>SET key value<strong>[EX seconds]</strong>     <strong>[PX milliseconds]</strong>   <strong>[NX|XX]</strong> </li>
<li><ul>
<li>EX second：设置键的过期时间为second秒</li>
<li>PX millisecond：设置键的过期时间为millisecond毫秒</li>
<li>NX：只要键不存在时，才对键进行设置操作</li>
<li>XX：只要键已经存在时，才对键进行设置操作</li>
<li>SET操作成功完成时，返回OK，否则返回nil</li>
</ul>
</li>
</ul>
<p>集中过期，由于存在大量的key很耗时，会出现短暂的卡顿现象</p>
<ul>
<li>解决方案：在设置key的过期时间的时候，给每个key加上随机值</li>
</ul>
<h3 id="如何实现异步队列"><a href="#如何实现异步队列" class="headerlink" title="如何实现异步队列"></a>如何实现异步队列</h3><p>BLPOP：阻塞直到队列有消息或者超时</p>
<ul>
<li>缺点：只能供一个消费者消费</li>
</ul>
<p>pub/sub：主题订阅者模式</p>
<ul>
<li>发送者pub发送消息，订阅者sub接收消息</li>
<li>订阅者可以订阅任意数量的频道</li>
</ul>
<p>pub/sub的缺点</p>
<ul>
<li>消息的发布是无状态的，无法保证可达</li>
</ul>
<h3 id="Redis如何做持久化"><a href="#Redis如何做持久化" class="headerlink" title="Redis如何做持久化"></a>Redis如何做持久化</h3><h4 id="RDB（快照持久化）：保存某个时间点的全量数据快照"><a href="#RDB（快照持久化）：保存某个时间点的全量数据快照" class="headerlink" title="RDB（快照持久化）：保存某个时间点的全量数据快照"></a>RDB（快照持久化）：保存某个时间点的全量数据快照</h4><ul>
<li>SAVE：阻塞Redis的服务器进程，直到EDB文件被创建完毕</li>
<li>BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器的进程</li>
</ul>
<p>自动化触发RDB持久化的方式</p>
<ul>
<li>根据redis.com配置里的SAVE m n定时触发（用的是BGSAVE）</li>
<li>主从复制时，主节点自动触发</li>
<li>执行Debug Reload</li>
<li>执行Shutdown且没有开启AOF持久化</li>
</ul>
<p>BGSAVE原理</p>
<ul>
<li>系统调用fork():创建进程，实现了Copy-on-Write</li>
</ul>
<p>Copy-on-Write</p>
<ul>
<li>如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调试者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变</li>
</ul>
<p>RDB持久化缺点</p>
<ul>
<li>内存数据的全量同步，数据量大会由于I/O而严重影响性能</li>
<li>可能会因为Redis挂掉而丢失从当前至最近以一次快照期间的数据</li>
</ul>
<h4 id="AOF（Append-Only-File）持久化：保存写状态"><a href="#AOF（Append-Only-File）持久化：保存写状态" class="headerlink" title="AOF（Append-Only-File）持久化：保存写状态"></a>AOF（Append-Only-File）持久化：保存写状态</h4><ul>
<li>记录了除了查询以外的所有变更数据库状态的指令</li>
<li>以append的形式追加保存到AOF文件中（增量）</li>
</ul>
<p>日志重写解决AOF文件大小不断增大的问题，原理如下：</p>
<ul>
<li>调用fork()，创建一个子进程</li>
<li>子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件</li>
<li>主进程持续将新的变动同时写到内存和原来的AOF里</li>
<li>主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动</li>
<li>使用新的AOF文件替换掉旧的AOF文件</li>
</ul>
<p>RDB和AOF</p>
<ul>
<li>RDB优点：全量数据快照，文件小，恢复快</li>
<li>RDB缺点：无法保存最近一次快照之后的数据</li>
<li>AOF优点：可读性高，适合保存增量数据，数据不易丢失</li>
<li>AOF缺点：文件体积大，恢复时间长</li>
</ul>
<h4 id="RDB-AOF混合持久化方式"><a href="#RDB-AOF混合持久化方式" class="headerlink" title="RDB-AOF混合持久化方式"></a>RDB-AOF混合持久化方式</h4><ul>
<li>BGSAVE做镜像全量持久化，AOF做增量持久化</li>
</ul>
<h3 id="Pipeline及主从同步"><a href="#Pipeline及主从同步" class="headerlink" title="Pipeline及主从同步"></a>Pipeline及主从同步</h3><p>使用Pipeline的好处</p>
<ul>
<li>Pipeline和linux的管道类似</li>
<li>Redis基于请求/相应模型，单个请求处理需要一一应答</li>
<li>Pipeline批量执行指令，节省多次IO往返的时间</li>
<li>有顺序依赖的指令分批发送</li>
</ul>
<p>Redis的同步机制</p>
<ul>
<li>主从同步原理</li>
<li><ul>
<li><a href="https://blog.csdn.net/qq_41724691/article/details/86616266" target="_blank" rel="noopener">原理</a></li>
</ul>
</li>
<li>全同步过程</li>
<li><ul>
<li>Slave发送sync命令到Master</li>
<li>Master启动一个后台进程，将Redis中的数据快照保存到文件中</li>
<li>Master将保存数据快照期间受到的写命令缓存起来</li>
<li>Master完成写文件操作后，将该文件发送给Slave</li>
<li>使用新的AOF文件替换掉旧的AOF文件</li>
<li>Master将这期间收集的增量写命令发送给Salve端</li>
</ul>
</li>
<li>增量同步过程</li>
<li><ul>
<li>Master接收到用户的操作指令，判断是否需要传播到Slave</li>
<li>将操作记录追加到AOF文件</li>
<li>将操作传播到其他Slave</li>
<li><ul>
<li>对齐主从库</li>
<li>往相应缓存写入指令</li>
</ul>
</li>
<li>将缓存中的数据发送给Slave</li>
</ul>
</li>
<li>Redis Sentinel</li>
<li><ul>
<li>解决主从同步Master宕机后的主从切换问题</li>
<li><ul>
<li>监控：检查主从服务器是否运行正常</li>
<li>提醒：通过API向管理员或者其他应用程序发送故障通知</li>
<li>自动故障迁移：主从切换</li>
</ul>
</li>
</ul>
</li>
<li>流言协议Gossip</li>
<li><ul>
<li>在杂乱无章中寻求一致</li>
<li><ul>
<li>每个节点都随机地与对方通信，最终所有节点的状态保持一致</li>
<li>种子节点定期随机向其他节点发送节点列表以及需要传播的信息</li>
<li>不保证信息一定会传递给所有节点，但是最终会趋于一致</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>如和从海量数据里找到所需？</p>
<ul>
<li>分片：按照某种规划去划分数据，分散存储在多个节点上</li>
<li>常规的按照哈希划分无法实现节点的动态增减</li>
</ul>
<p>Redis集群原理</p>
<ul>
<li>一致性哈希算法</li>
<li><ul>
<li>对2^32取模，将哈希值空间组织成虚拟的圆环</li>
<li>将数据key使用相同的函数Hash计算出哈希值</li>
</ul>
</li>
<li>引入虚拟节点解决数据倾斜的问题</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="Linux的体系结构"><a href="#Linux的体系结构" class="headerlink" title="Linux的体系结构"></a>Linux的体系结构</h3><ul>
<li>体系结构主要分为用户态（用户上层活动）和内核态</li>
<li>内核：本质是一段管理计算机硬件设备的程序</li>
<li>系统调用：内核的访问接口，是一种能再简化的操作</li>
<li>公用函数库：系统调用的组合拳</li>
<li>Shell：命令解释器，可编程</li>
</ul>
<h3 id="查找特定的文件"><a href="#查找特定的文件" class="headerlink" title="查找特定的文件"></a>查找特定的文件</h3><p>find</p>
<ul>
<li>作用：在指定目录下查找文件</li>
</ul>
<p>面试里常用的方式</p>
<ul>
<li>find ~ -name “target3.java” 精确查找文件</li>
<li>find ~ -name “target” 模糊查找文件</li>
<li>find ~ -iname “target*” 不区分文件名大小写去查找文件</li>
<li>man find：更多关于find指令的使用说明</li>
</ul>
<h3 id="检索文件的内容"><a href="#检索文件的内容" class="headerlink" title="检索文件的内容"></a>检索文件的内容</h3><p>grep</p>
<ul>
<li>全称：Global Regular Expression Print</li>
<li>作用：查找文件里符合条件的字符串</li>
</ul>
<p>管道操作符</p>
<ul>
<li>可将指令链接起来，前一个指令的输出作为后一个指令的输入</li>
</ul>
<p>使用管道注意的要点</p>
<ul>
<li>只处理一个命令正确输出，不处理错误输出</li>
<li>右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃</li>
<li>sed，awk，grep，cut，head，top，less，more，wc，join，sort，split等</li>
</ul>
<h3 id="对文件内容做统计"><a href="#对文件内容做统计" class="headerlink" title="对文件内容做统计"></a>对文件内容做统计</h3><p>awk</p>
<ul>
<li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分</li>
<li>将切片直接保存在内建的变量中，$1,$2…($0表示行的全部)</li>
<li>支持对单个切片的判断，支持循环判断，默认分隔符为空格</li>
</ul>
<h3 id="批量替换文件内容"><a href="#批量替换文件内容" class="headerlink" title="批量替换文件内容"></a>批量替换文件内容</h3><p>sed</p>
<ul>
<li>全名stream editor 流编辑器</li>
<li>适合对文本的行内容进行处理</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="谈谈你对java的理解"><a href="#谈谈你对java的理解" class="headerlink" title="谈谈你对java的理解"></a>谈谈你对java的理解</h3><ul>
<li>平台无关行</li>
<li>GC（垃圾回收机制）</li>
<li>语言特性（泛型，反射等）</li>
<li>面向对象</li>
<li>类库</li>
<li>异常处理</li>
</ul>
<h3 id="Compile-Once-Run-Anywhere如何实现"><a href="#Compile-Once-Run-Anywhere如何实现" class="headerlink" title="Compile Once ,Run Anywhere如何实现"></a>Compile Once ,Run Anywhere如何实现</h3><p>javap -c对代码进行反汇编</p>
<p>Javac编译，生成字节码；JVM解析，转换成特定平台的执行指令</p>
<p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台是运行不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。</p>
<p>问：为什么JVM不直接把源码解析成机器码去执行？</p>
<ul>
<li>准备工作：每次执行都需要各种检查</li>
<li>兼容性：也可以将别的语言解析成字节码</li>
</ul>
<h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><p>Java虚拟机</p>
<ul>
<li>Class Loader：依据特定格式，加载class文件到内存</li>
<li>Execution Engine：对命令进行解析</li>
<li>Native Interface：融合不同开发语言的原生库为Java所用</li>
<li>Runtime Data Area：JVM内存空间结构模型</li>
</ul>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Robot.java</span></span><br><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String helloSentence)</span></span>&#123;</span><br><span class="line">        System.out.println(helloSentence+<span class="string">" "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">throwHello</span><span class="params">(String tag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span> + tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReflectSample.java</span></span><br><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class rc = Class.forName(<span class="string">"reflect.Robot"</span>);</span><br><span class="line">        Robot r = (Robot) rc.newInstance();</span><br><span class="line">        System.out.println(<span class="string">"Class name is "</span> + rc.getName());</span><br><span class="line">        r.sayHi(<span class="string">"bob"</span>);</span><br><span class="line">        Method getHello = rc.getDeclaredMethod(<span class="string">"throwHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        getHello.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object str = getHello.invoke(r, <span class="string">"Bob"</span>);</span><br><span class="line">        System.out.println(<span class="string">"getHello result is "</span>+ str);</span><br><span class="line"></span><br><span class="line">        Method sayHi = rc.getDeclaredMethod(<span class="string">"sayHi"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sayHi.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field name = rc.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(r, <span class="string">"Alice"</span>);</span><br><span class="line">        sayHi.invoke(r, <span class="string">"Welcome"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Class name is reflect.Robot</span><br><span class="line">bob <span class="keyword">null</span></span><br><span class="line">getHello result is HelloBob</span><br><span class="line">Welcome Alice</span><br></pre></td></tr></table></figure></div>

<h3 id="谈谈ClassLoader"><a href="#谈谈ClassLoader" class="headerlink" title="谈谈ClassLoader"></a>谈谈ClassLoader</h3><p>类从编译到执行的过程</p>
<ul>
<li>编译器将Robot.java源文件编译为Robot.class字节码文件</li>
<li>ClassLoader将字节码转换为JVM中的Class<robot>对象</robot></li>
<li>JVM利用Class<robot>对象实例化为Robot对象</robot></li>
</ul>
<p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class的二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。</p>
<p>ClassLoader的种类</p>
<ul>
<li>BootStrapClassLoader：C++编写，加载和辛苦java.*</li>
<li>ExtClassLoader：Java编写，加载扩展库javax.*</li>
<li>AppClassLoader：Java编写，加载程序所在目录</li>
<li>自定义ClassLoader：Java编写，定制化加载</li>
</ul>
<h3 id="谈谈类加载器的双亲委派机制"><a href="#谈谈类加载器的双亲委派机制" class="headerlink" title="谈谈类加载器的双亲委派机制"></a>谈谈类加载器的双亲委派机制</h3><p><a href="https://blog.csdn.net/yan245294305/article/details/86777503" target="_blank" rel="noopener">https://blog.csdn.net/yan245294305/article/details/86777503</a></p>
<h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><ul>
<li>隐式加载：new</li>
<li>显式加载：loadClass，forName等</li>
</ul>
<p>loadClass和forName的区别</p>
<p>类的装载过程</p>
<ul>
<li>加载：通过ClassLoader加载class文件字节码，生成Class对象</li>
<li>链接</li>
<li><ul>
<li>校验：检查加载的class的正确性和安全性</li>
<li>准备：为类变量分配存储空间并设置类变量初始值</li>
<li>解析：JVM将变量池内的符号引用转换为直接引用</li>
</ul>
</li>
<li>初始化：执行类变量赋值和静态代码块</li>
</ul>
<p>loadClass和forName的区别</p>
<ul>
<li>Class.forName得到的class是已经初始化完成的</li>
<li>ClassLoader.loadClass得到的class是还没有链接的</li>
</ul>
<h3 id="Java的内存模型"><a href="#Java的内存模型" class="headerlink" title="Java的内存模型"></a>Java的内存模型</h3><p>JVM内存模型——JDK8</p>
<ul>
<li>线程私有：程序计数器，虚拟机栈，本地方法栈</li>
<li>线程共享：MetaSpace、Java堆</li>
</ul>
<p>程序计数器</p>
<ul>
<li>当前进程所执行的字节码行号指示器（逻辑）</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程是一对一的关系即“线程私有”</li>
<li>对Java方法计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄漏</li>
</ul>
<p>Java虚拟机栈（Stack）</p>
<ul>
<li>Java方法执行的内存模型</li>
<li>包含多个栈帧（局部变量表，操作数栈，动态链接，返回地址）</li>
</ul>
<p>局部变量表和操作数栈</p>
<ul>
<li>局部变量表：包含方法执行过程中的所有变量</li>
<li>操作数栈：入栈，出栈，复制，交换，产生消费变量 </li>
</ul>
<p>递归为什么会引发java.lang.StackOverflowError异常</p>
<ul>
<li>递归过深，栈帧数超出虚拟栈深度</li>
</ul>
<p>本地方法栈</p>
<ul>
<li>与虚拟机栈相似，主要作用于标注了native方法</li>
</ul>
<p>元空间MetaSpace与永久代PermGen的区别</p>
<ul>
<li>元空间使用本地内存，而永久代使用的是jvm的内存</li>
</ul>
<p>MetaSpace相比PermGen的优势</p>
<ul>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性</li>
<li>方便HotSpot与其他JVM如Jrockit集成</li>
</ul>
<p>Java堆（Heap）</p>
<ul>
<li>对象实例的分配区域</li>
<li>GC管理的主要区域</li>
</ul>
<h3 id="常考题解析"><a href="#常考题解析" class="headerlink" title="常考题解析"></a>常考题解析</h3><p>JVM三大性能调优参数 -Xms -Xmx -Xss的含义</p>
<ul>
<li>-Xms：规定了每个线程虚拟机栈（堆栈）的大小</li>
<li>-Xms：堆的初始值</li>
<li>-Xmx：堆能够达到的最大值</li>
</ul>
<p>Java内存模型中堆和栈的区别——内存分配策略</p>
<ul>
<li>静态存储：编译时确定每个数据目标在运行时的存储空间要求</li>
<li>栈式存储：数据区要求在编译时未知，运行时模块入口前确定</li>
<li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li>
</ul>
<p>Java内存模型中堆和栈的区别</p>
<ul>
<li>管理方式：栈自动释放，堆需要GC</li>
<li>空间大小：栈比堆小</li>
<li>碎片相关：堆产生的碎片远小于堆</li>
<li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li>
<li>效率：栈的效率比堆高</li>
</ul>
<h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h3 id="垃圾回收之标记算法"><a href="#垃圾回收之标记算法" class="headerlink" title="垃圾回收之标记算法"></a>垃圾回收之标记算法</h3><p>对象被判定为垃圾的标准</p>
<ul>
<li>没有被其他对象引用</li>
<li><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
</li>
</ul>
<p>引用计数算法</p>
<ul>
<li>通过判断对象的引用数量来决定对象是否可以被回收</li>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li>
<li>任何引用计数为0的对象可以被当做垃圾收集</li>
<li>优点：执行效率高，程序执行受影响较小</li>
<li>缺点：无法检测出循环引用的情况，导致内存泄漏</li>
</ul>
<p>可达性分析算法</p>
<ul>
<li>通过判断对象的引用链是否可达来决定对象是否可以被回收</li>
<li>可以作为GC Root的对象</li>
<li><ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中JNI（Native方法）的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>
</li>
</ul>
<h3 id="谈谈你了解的垃圾回收算法"><a href="#谈谈你了解的垃圾回收算法" class="headerlink" title="谈谈你了解的垃圾回收算法"></a>谈谈你了解的垃圾回收算法</h3><p>标记-清楚算法（Mark and Sweep）（缺点：碎片化）</p>
<ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</li>
</ul>
<p>复制算法（Copying）</p>
<ul>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建</li>
<li>存活的对象被从对象面复制到空闲面</li>
<li>将对象面所有对象内存清除</li>
<li>优点：</li>
<li><ul>
<li>解决碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象<strong>存活率低</strong>的场景</li>
</ul>
</li>
</ul>
<p>标记-整理算法（Compacting）</p>
<ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。</li>
<li>优点</li>
<li><ul>
<li>避免内存的不连续性</li>
<li>不用设置俩块内存互换</li>
<li>适用于<strong>存活率高</strong>的场景</li>
</ul>
</li>
</ul>
<p>分代收集算法（Generational Collector）</p>
<ul>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分趋于以采用不用的垃圾回收算法</li>
<li>目的：提高JVM的回收效率</li>
</ul>
<p>GC的分类</p>
<ul>
<li>Minor GC</li>
<li>Full GC</li>
</ul>
<p>年轻代：尽可能快速地收集掉那些生命周期短的对象</p>
<ul>
<li>Eden区</li>
<li>两个Survivor区</li>
</ul>
<p>对象如何晋升到老年代</p>
<ul>
<li>经历一定Minor次数依然存活的对象</li>
<li>Survivor区中存活不下的对象</li>
<li>新生成的大对象（-XX：+PretenuerSizeThreshold）</li>
</ul>
<p>常用的调优参数</p>
<ul>
<li>-XX：SurvivorRatio：Eden和Survivor的比值i，默认8:1</li>
<li>-XX：NewRatio：老年代和年轻代内存大小的比例</li>
<li>-XX：MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值</li>
</ul>
<p>老年代：存放生命周期较长的对象</p>
<ul>
<li>标记-清理算法</li>
<li>标记-整理算法</li>
</ul>
<p>老年代</p>
<ul>
<li>Full GC和Major GC</li>
<li>Full GC比Minor GC慢，但执行频率低</li>
</ul>
<p>触发Full GC的条件</p>
<ul>
<li>老年代空间不足</li>
<li>永久代空间不足</li>
<li>CMS GC时出现promotion failed，concurrrent mode failure</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>
<h3 id="分带收集算法（Generational-Collector）"><a href="#分带收集算法（Generational-Collector）" class="headerlink" title="分带收集算法（Generational Collector）"></a>分带收集算法（Generational Collector）</h3><p>Stop-the-World</p>
<ul>
<li>JVM由于要执行GC而停止了应用程序的执行</li>
<li>任何一种GC算法中都会发生</li>
<li>多数GC优化通过减少Stop-the-world发生的时间来提高程序性能</li>
</ul>
<p>Safepoint</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点</li>
<li>产生Safepoint的地方：方法调用；循环跳转；异常跳转等</li>
<li>安全点数量得时钟</li>
</ul>
<h3 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h3><p>JVM的运行模式</p>
<ul>
<li>Server</li>
<li>Client</li>
</ul>
<p><strong>年轻代常见的垃圾收集器</strong></p>
<p>Serial收集器(-XX:+UseSerialGC,复制算法)</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的年轻代收集器</li>
</ul>
<p>ParNew收集器（-XX：+UseParNewGC，复制算法）</p>
<ul>
<li>多线程收集，其余的行为、特点和Serial收集器一样</li>
<li>单核执行效率不如Serial，在多核下执行才有优势</li>
</ul>
<p>Parallel Scavenge（-XX：+UseParallelGC，复制算法）</p>
<ul>
<li>吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>
<li>比起关注用户线程停顿时间，更关注系统的吞吐量</li>
<li>在多核下执行才有优势，Server模式下默认的年轻代收集器</li>
</ul>
<p><strong>老年代常见的垃圾收集器</strong></p>
<p>Serial Old收集器（-XX：+UseSerialOldGC，标记-整理算法）</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作进程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
<p>Parallel Old收集器（-XX：+UseParallelGC，标记-整理算法）</p>
<ul>
<li>多线程，吞吐量优先</li>
</ul>
<p>CMS收集器（-XX：+UseConcMarkSweepGC，标记-清除算法）</p>
<ul>
<li>初始标记：stop-the-world</li>
<li>并发标记：并发追溯标记，程序不会停顿</li>
<li>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的现象</li>
<li>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</li>
<li>并发清理：清理垃圾对象，程序不会停顿</li>
<li>并发重置：重置CMS收集器的数据结构</li>
</ul>
<p>G1收集器（-XX：+UseG1GC，复制+标记-整理算法）</p>
<p>Garbage First收集器的特点</p>
<ul>
<li>并行和并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ul>
<p>Garbage First收集器</p>
<ul>
<li>将整个Java堆内存划分成多个大小相等的Region</li>
<li>年轻代和老年代不再物理隔离</li>
</ul>
<h3 id="GC相关的面试题"><a href="#GC相关的面试题" class="headerlink" title="GC相关的面试题"></a>GC相关的面试题</h3><p>Object的finalize()方法的作用是否与C++的析构函数作用相同</p>
<ul>
<li>与C++的析构函数不同，析构函数调用确定，而它的是不确定的</li>
<li>将未被引用的对象放置于F-Queue队列</li>
<li>方法执行随时可能会被终止</li>
<li>给予对象最后一次重生的机会</li>
</ul>
<p>Java中的强引用，软引用，弱引用，虚引用有什么用</p>
<ul>
<li>强引用（Strong Reference）</li>
<li><ul>
<li>最普遍的引用：Object obj = new Object()</li>
<li>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</li>
<li>通过将对象设置为null来弱化引用，使其被回收</li>
</ul>
</li>
<li>软引用（Soft Reference）</li>
<li><ul>
<li>对象处在游泳但非必须的状态</li>
<li>只有当内存空间不足时，GC会回收该引用的对象的内存</li>
<li>可以用来实现高速缓存</li>
</ul>
</li>
<li>弱引用（Weak Reference）</li>
<li><ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>GC时会被回</li>
<li>被回收的概率也不大，因为GC线程优先级比较低</li>
<li>适用于引用偶尔被使用且不影响垃圾收集的对象</li>
</ul>
</li>
<li>虚引用（PhantomReference）</li>
<li><ul>
<li>不会决定对象的声明周期</li>
<li>任何时候都可以被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>必须和引用队列ReferenceQueue联合使用</li>
</ul>
</li>
</ul>
<p>引用队列（Reference Queue）</p>
<ul>
<li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达</li>
<li>存储关联的且被GC的软引用，弱引用以及虚引用</li>
</ul>
<h1 id="java多线程与并发"><a href="#java多线程与并发" class="headerlink" title="java多线程与并发"></a>java多线程与并发</h1><h3 id="start和run方法的区别"><a href="#start和run方法的区别" class="headerlink" title="start和run方法的区别"></a>start和run方法的区别</h3><ul>
<li>调用start()方法会创建一个新的子线程并启动</li>
<li>run()方法只是Thread的一个普通方法的调用</li>
</ul>
<h3 id="Thread和Runnable是什么关系"><a href="#Thread和Runnable是什么关系" class="headerlink" title="Thread和Runnable是什么关系"></a>Thread和Runnable是什么关系</h3><ul>
<li>Thread是实现Runnable接口的类，使得run支持多线程</li>
<li>因类的单一继承原则，推荐多使用Runnable接口</li>
</ul>
<h3 id="如何给run-方法传参"><a href="#如何给run-方法传参" class="headerlink" title="如何给run()方法传参"></a>如何给run()方法传参</h3><ul>
<li>构造函数</li>
<li>成员变量</li>
<li>回调函数</li>
</ul>
<h3 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h3><ul>
<li>主线程等待法</li>
<li>使用Thread类的join()阻塞当前进程以等待子线程处理完毕</li>
<li>通过Callable接口实现：通过FutureTask Or线程池获取</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li>新建New</li>
<li>运行Runnable</li>
<li>无限期等待Waiting</li>
<li>限期等待Timed Waiting</li>
<li>阻塞Blocked</li>
<li>结束Terminated</li>
</ul>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul>
<li>sleep是Thread类的方法，wait是Object类的方法</li>
<li>sleep()方法可以在任何地方使用</li>
<li>wait()方法只能在synchronized方法或synchronized块中使用</li>
</ul>
<p><strong>最本质的区别</strong></p>
<ul>
<li>Thread.sleep只会让出CPU，不会导致锁行为的改变(不会让出锁)</li>
<li>Object.wait不仅让出CPU，还会释放已经占有的同步资源锁</li>
</ul>
<h3 id="yield函数"><a href="#yield函数" class="headerlink" title="yield函数"></a>yield函数</h3><ul>
<li>当调用Thread.yield()函数，会给线程调度器一个当前进程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示</li>
</ul>
<h3 id="interrupt函数"><a href="#interrupt函数" class="headerlink" title="interrupt函数"></a>interrupt函数</h3><p><strong>如何中断线程</strong></p>
<p>调用interrupt()，通知线程应该中断了</p>
<ul>
<li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常</li>
<li>如果线程处于正常活动状态，那么会将线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响</li>
</ul>
<h1 id="java多线程与并发原理"><a href="#java多线程与并发原理" class="headerlink" title="java多线程与并发原理"></a>java多线程与并发原理</h1><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote>
<p>Monitor:每个java对象天生自带了一把看不见的锁</p>
</blockquote>
<blockquote>
<p>重入：从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入</p>
</blockquote>
<blockquote>
<p>自旋锁：1 许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得</p>
<p>2 通过让线程执行忙循环等待锁的释放，不让出CPU</p>
<p>缺点:若锁被其他线程长时间占用，会带来许多性能上的开销</p>
</blockquote>
<blockquote>
<p>自适应自旋锁：1 自旋的次数不再固定</p>
<p>2 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</p>
</blockquote>
<blockquote>
<p>锁消除：更彻底的优化</p>
</blockquote>
<blockquote>
<p>锁粗化：另一种极端</p>
</blockquote>
<blockquote>
<p>synchronized的四种状态：无锁，偏向锁，轻量级锁，重量级锁</p>
<p>锁膨胀方向：无锁→偏向锁→轻量级锁→重量级锁</p>
</blockquote>
<blockquote>
<p>偏向锁:减少同一线程获得锁的代价</p>
<ul>
<li>大多数情况下，锁不存在多线程竞争，总是由同一个线程多次获得</li>
</ul>
<p>锁的内存语义：当线程释放锁时，java内存模型会把该线程对应的本地内存中的共享变量刷新到主内存中；</p>
<p>而当线程获取锁时，Java内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p>
</blockquote>
<h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><blockquote>
<p>ReentrantLock(再入锁)</p>
<ul>
<li>位于java.util.concurrent.locks包</li>
<li>和CountDownLatch、FutureTask、Samaphore一样基于AQS实现</li>
<li>能够实现 比synchronized更细粒度的控制，如控制fairness</li>
<li>调用lock()之后，必须调用unlock()释放锁</li>
<li>性能未必比synchronized高，并且也是可重入的</li>
</ul>
</blockquote>
<blockquote>
<p>ReentrantLock公平性的设置</p>
<ul>
<li>RentrantLock faiLock = new ReentrantLock(true);</li>
<li>参数为true时，倾向于将锁赋予等待时间最久的线程</li>
<li>公平锁：获取锁的顺序按先后调用lock方法的顺序（慎用）</li>
<li>非公平锁：抢占的顺序不一定，看运气</li>
<li>synchronized是非公平锁</li>
</ul>
</blockquote>
<blockquote>
<p><strong><em>区别</em></strong></p>
<p>ReentrantLock将锁对象化</p>
<ul>
<li>判断是否有线程，或者某个特定线程，在排队等待获取锁</li>
<li>带超时的获取锁的尝试</li>
<li>感知有没有成功获取锁</li>
</ul>
</blockquote>
<h3 id="什么是Java内存模型中的happens-before"><a href="#什么是Java内存模型中的happens-before" class="headerlink" title="什么是Java内存模型中的happens-before"></a>什么是Java内存模型中的happens-before</h3><blockquote>
<p>Java内存模型JMM</p>
<p>本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实力字段，静态字段和构成数组对象的元素）的访问方式。</p>
</blockquote>
<blockquote>
<p>JMM与Java内存区域划分是不同的概念层次</p>
<ul>
<li>JMM描述的是一组规则，围绕原子性，有序性，可见性展开</li>
<li>相似点：存在共享区域和私有区域</li>
</ul>
</blockquote>
<blockquote>
<p>主内存与工作内存的数据存储类型以及操作方式归纳</p>
<ul>
<li>方法里的基本数据类型本地变量将直接存储在工作内存的帧栈结构中</li>
<li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li>
<li>成员变量，static变量，类信息均会存储在主内存中</li>
<li>主内存共享的方式是线程各拷贝一份数据到工作内存中，操作完成后刷新回主内存</li>
</ul>
</blockquote>
<h3 id="JMM如何解决可见性问题"><a href="#JMM如何解决可见性问题" class="headerlink" title="JMM如何解决可见性问题"></a>JMM如何解决可见性问题</h3><blockquote>
<p><em>指令重排序需要满足的条件</em></p>
<ul>
<li>在单线程环境下不能改变程序运行的结果</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p>无法通过happens-before原则推导出来的，才能进行指令的重排序</p>
<p>A操作的结果需要对B操作可见，则A和B存在happens-before关系</p>
</blockquote>
<blockquote>
<p>volatile:JVM提供的轻量级同步机制</p>
<ul>
<li>保证被volatile修饰的共享变量对所有线程总是可见的</li>
<li>禁止指令重排序优化</li>
</ul>
<p>volatile变量为何立即可见？</p>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中</li>
<li>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效</li>
</ul>
<p>volatile如何禁止重排优化？</p>
<ul>
<li>内存屏障（Memory Barrier）</li>
<li><ul>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性</li>
</ul>
</li>
<li>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化</li>
<li>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本</li>
</ul>
</blockquote>
<blockquote>
<p>volatile和synchronized的区别</p>
<ul>
<li>volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法和类级别</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量修改的可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
</ul>
</blockquote>
<h3 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare and Swap）"></a>CAS（Compare and Swap）</h3><blockquote>
<p>一种高效实现线程安全性的方法</p>
<ul>
<li>支持原子更细操作，适用于计数器，序列发生器等场景</li>
<li>属于乐观锁机制，号称lock-free</li>
<li>CAS操作失败时由开发者决定是继续尝试，还是执行别的操作</li>
</ul>
<p>CAS思想</p>
<ul>
<li>包含三个操作数——内存位置（V）、预期原值（A）和新值（B）</li>
</ul>
<p>CAS多数情况下对开发者来说是透明的</p>
<ul>
<li>J.U.C的atomic包提供了常用的原子性数据类型以及引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选</li>
<li>Unsafe类虽提供了CAS服务，但因能够操纵任意内存地址读写而有隐患</li>
<li>Java9以后，可以使用Variable Handle API来替代Unsafe</li>
</ul>
<p>缺点</p>
<ul>
<li>若循环时间长，则开销很大</li>
<li>只能保证一个共享变量的原子操作</li>
<li>ABA问题 解决：AtomicStampedReference</li>
</ul>
</blockquote>
<h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><blockquote>
<p>利用Executors创建不用的线程池满足不同场景的需求</p>
</blockquote>
<blockquote>
<p>Fork/Join框架</p>
<ul>
<li>把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大人物结果的框架</li>
</ul>
<p>为什么要使用线程池</p>
<ul>
<li>降低资源消耗</li>
<li>提高线程的可管理性</li>
</ul>
</blockquote>
<blockquote>
<p>J.U.C的三个Executor接口</p>
<ul>
<li>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</li>
<li>ExecutorService:具备管理执行器和任务生命周期的方法，提交任务机制更完善</li>
<li>ScheduleExecutorService：支持Future和定期执行任务</li>
</ul>
</blockquote>
<blockquote>
<p>ThreadPoolExecutor的构造函数</p>
<ul>
<li>corePoolSize：核心线程数量</li>
<li>maximumPoolSize：线程不够用时创建的最大线程数</li>
<li>workQueue：任务等待队列</li>
<li>keepAliveTime：抢占的顺序不一定，看运气</li>
</ul>
</blockquote>
<blockquote>
<p>线程池的状态</p>
<ul>
<li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN：不再接受新提交的任务，但可以处理存量任务</li>
<li>STOP：不再接受新提交的任务，也不处理存量任务</li>
<li>TIDYING：所有的任务都已终止</li>
<li>TERMINATED：terminated（）方法执行完后进入该状态</li>
</ul>
</blockquote>
<blockquote>
<p>线程池的大小如何选定</p>
<ul>
<li>CPU密集型：线程数 = 按照核数或者核数+1设定</li>
<li>I/O密集型：线程数*（1+平均等待时间/平均工作时间）</li>
</ul>
</blockquote>
<h1 id="常见类库与技巧"><a href="#常见类库与技巧" class="headerlink" title="常见类库与技巧"></a>常见类库与技巧</h1><h3 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h3><blockquote>
<p>Error和Exception的区别</p>
<ul>
<li>Error：程序无法处理的系统错误，编译器不做检查</li>
<li>Exception：程序无法处理的异常，捕获后可能恢复</li>
<li>总结：前者是程序无法处理的错误，后者是可以处理的异常</li>
</ul>
</blockquote>
<blockquote>
<p>Exception</p>
<ul>
<li>RuntimeException：不可预知，程序应当自行避免</li>
<li>非RuntimeException：可预知的，从编译器检验的异常</li>
</ul>
</blockquote>
<h3 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h3><blockquote>
<ul>
<li>抛出异常：创建异常对象，交由运行时系统处理</li>
<li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li>
</ul>
</blockquote>
<blockquote>
<p>异常的处理原则</p>
<ul>
<li>具体明确：抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因</li>
<li>提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题</li>
<li>延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常。</li>
</ul>
</blockquote>
<blockquote>
<p>在用户看来，应用系统发生的所有异常都是应用系统内部的异常</p>
<ul>
<li>设计一个通用的继承自RuntimeException的异常来统一处理</li>
<li>其余异常都统一转译为上述异常AppException</li>
<li>在catch之后，抛出上述异类的子类，并提供足以定位的信息</li>
<li>由前端接收APPException做统一处理</li>
</ul>
</blockquote>
<blockquote>
<p>Java异常处理性能的地方</p>
<ul>
<li>try-catch块影响JVM的优化</li>
<li>异常对象实例需要保存栈快照等信息，开销较大</li>
</ul>
</blockquote>
<h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><blockquote>
<p>List、Set、Map等</p>
</blockquote>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap、HashTable、ConccurentHashMap</p>
<blockquote>
<p>HashMap(Java8以前)：数组+链表；（Java8及以后）数组+链表+红黑树</p>
<p>性能从O（n）提高到O（logn）</p>
<p>HashMap：如何有效减少碰撞</p>
<ul>
<li>扰动函数：促使元素位置分布均匀，减少碰撞机率</li>
<li>使用final对象，并采用合适的equals()和hashCode()方法</li>
</ul>
<p>HashMap：扩容的问题</p>
<ul>
<li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li>
<li>rehashing是一个比较耗时的过程</li>
</ul>
</blockquote>
<blockquote>
<p>如何优化HashTABLE？</p>
<ul>
<li>通过锁细粒度化，将整锁拆解成多个锁进行优化</li>
</ul>
</blockquote>
<blockquote>
<p>三者的区别</p>
<ul>
<li>HashMap线程不安全，数组+链表+红黑树</li>
<li>HashTable线程安全，锁住整个对象，数组+链表</li>
<li>ConccurentHashMap线程安全，CAS+同步锁，数组+链表+红黑树</li>
<li>HashMap的key、value均可为null，而其他的俩个类不支持</li>
</ul>
</blockquote>
<h3 id="J-U-C知识点梳理"><a href="#J-U-C知识点梳理" class="headerlink" title="J.U.C知识点梳理"></a>J.U.C知识点梳理</h3><blockquote>
<p>java.util.concurrent:提供了并发编程的解决方案</p>
<ul>
<li>CAS是java.util.concurrent.atomic包的基础</li>
<li>AQS是java.util.concurrent.locks包以及一些常用类比如Semophore，ReentrantLock等类的基础</li>
</ul>
</blockquote>
<blockquote>
<p>J.U.C包的分类</p>
<ul>
<li>线程执行器executor</li>
<li>锁locks</li>
<li>原子变量类atomic</li>
<li>并发工具类tools</li>
<li>并发集合collections</li>
</ul>
</blockquote>
<blockquote>
<p>并发工具类</p>
<ul>
<li>闭锁 CountDownLatch</li>
<li>栅栏 CyclicBarrier</li>
<li>信号量 Semaphore</li>
<li>交换器 Exchanger</li>
</ul>
</blockquote>
<blockquote>
<p>CountDownLatch：让主线程等待一组事件发生后继续执行</p>
<ul>
<li>事件指的是CountDownLatch里的countDown()方法</li>
</ul>
</blockquote>
<blockquote>
<p>CyclicBarrier:阻塞当前线程，等待其他线程</p>
<ul>
<li>等待其他线程，且会阻塞自己当前线程，所有线程必须同时到达栅栏位置后，才会继续执行</li>
<li>所有线程到达栅栏处，可以触发执行另外一个预先设置的线程</li>
</ul>
</blockquote>
<blockquote>
<p>Semaphore：控制某个资源可被同时访问的线程个数</p>
</blockquote>
<blockquote>
<p>Exchanger：俩个线程到达同步点后，相互交换数据</p>
</blockquote>
<blockquote>
<p>BlockingQueue：提供可阻塞的入队和出队操作</p>
<p>主要用于生产者-消费者模式，在多线程场景时生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够达到将添加任务的生产和消费进行隔离的目的</p>
<ol>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PrioriyuBlockingQueue</li>
<li>DealyQueue</li>
<li>SynchronousQueue</li>
<li>LinkedTransferQueue</li>
<li>LinkedBlockingDeque</li>
</ol>
</blockquote>
<h3 id="Java的IO机制"><a href="#Java的IO机制" class="headerlink" title="Java的IO机制"></a>Java的IO机制</h3><blockquote>
<p>NonBlock-IO：构建多路复用的、同步非阻塞的IO操作</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>NIO-Channels</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>NIO-Buffers</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
<li>MappedByteBuffer</li>
</ul>
</blockquote>
<blockquote>
<p>select、poll、epoll区别：略</p>
</blockquote>
<blockquote>
<p>Asynchronous IO：基于事件和回调机制</p>
<p>AIO如何进一步加工处理结果</p>
<ul>
<li>基于回调：实现CompletionHandler接口，调用时触发回调函数</li>
<li>返回Future：通过isDone()查看是否准备好，通过get()等待返回数据</li>
</ul>
</blockquote>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="IOC-（Inversion-of-control）-控制反转"><a href="#IOC-（Inversion-of-control）-控制反转" class="headerlink" title="IOC （Inversion of control） 控制反转"></a>IOC （Inversion of control） 控制反转</h3><blockquote>
<p>IOC容器的优势</p>
<ul>
<li>避免在各处使用new来创建类，并且可以做到统一维护</li>
<li>创建实例的时候不需要了解其中的细节</li>
</ul>
</blockquote>
<h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><blockquote>
<p>Spring IOC支持的功能</p>
<ul>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>指定初始化方法和销毁方法</li>
<li>支持回调方法</li>
</ul>
</blockquote>
<blockquote>
<p>ApplicationContext的功能（继承多个接口）</p>
<ul>
<li>BeanFactory：能够管理、装配多个Bean</li>
<li>ResourcePatternResolver：能够加载资源文件</li>
<li>MessageSource：能够实现国际化等功能</li>
<li>ApplicationEventPublisher：能够注册监听器，实现监听机制</li>
</ul>
</blockquote>
<h3 id="getBean方法解析"><a href="#getBean方法解析" class="headerlink" title="getBean方法解析"></a>getBean方法解析</h3><blockquote>
<p>getBean方法的代码逻辑</p>
<ul>
<li>转换beanName</li>
<li>从缓存中加载实例</li>
<li>实例化Bean</li>
<li>检查parentBeanFactory</li>
<li>初始化依赖的Bean</li>
<li>创建Bean</li>
</ul>
</blockquote>
<blockquote>
<p>Spring Bean的作用域</p>
<ul>
<li>singleton：Spring的默认作用域，容器里拥有唯一的Bean实例</li>
<li>prototype：针对每个getBean请求，容器都会创建一个Bean实例</li>
<li>request：会为每个HTTP请求创建一个Bean实例</li>
<li>session：会为每个session创建一个Bean实例</li>
<li>globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效</li>
</ul>
</blockquote>
<blockquote>
<p>Bean的生命周期-销毁过程</p>
<ul>
<li>若实现了DisposableBean接口，则会调用destroy()方法</li>
<li>若配置了destroy-method属性，则会调用其配置的销毁方法</li>
</ul>
</blockquote>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><blockquote>
<p>关注点分离：不同的问题交给不同的部分去解决</p>
<ul>
<li>面向切面编程AOP正式此种技术的提现</li>
<li>通用功能化代码的实现，对应的就是所谓的切面Aspect</li>
<li>业务功能代码和切面代码分开后，架构将变得高内聚低耦合</li>
<li>确保功能的完整性：切面最终需要被合并到业务中Weave</li>
</ul>
</blockquote>
<blockquote>
<p>AOP的三种织入方式</p>
<ul>
<li>编译时织入：需要特殊的Java编译器，入AspectJ</li>
<li>类加载时织入：需要特殊的Java编译器，入AspectJ和AspectWerkz</li>
<li>运行时织入：Spring采用的方式，采用动态代理的方式，实现简单</li>
</ul>
</blockquote>
<blockquote>
<p>AOP的主要名词概念</p>
<ul>
<li>Aspect：通用功能的代码实现</li>
<li>Target：被织入Aspect的对象</li>
<li>Join Point：可以作为切入点的机会，所有方法都可以作为切入点</li>
<li>Pointcut：Aspect实际被应用在的Join Point，支持正则</li>
<li>Advice：类里的方法以及这个方法如何织入到目标方法的方式</li>
<li>Weaving：Aop的实现过程</li>
</ul>
</blockquote>
<blockquote>
<p>Advice的种类</p>
<ul>
<li>前置</li>
<li>后置</li>
<li>异常</li>
<li>最终</li>
<li>环绕</li>
</ul>
</blockquote>
<h3 id="Spring-AOP的原理"><a href="#Spring-AOP的原理" class="headerlink" title="Spring AOP的原理"></a>Spring AOP的原理</h3><blockquote>
<p>AOP的实现：JDKProxy和Cglib</p>
<ul>
<li>由AopProxyFactory根据AdvisedSupport对象的配置来决定</li>
<li>默认策略如果目标类是接口，则用JDKProxy来实现，否则用后者</li>
<li>JDKProxy的核心：InvocationHandler接口和Proxy类</li>
<li>Cglib：以继承的方式动态生成目标类的代理</li>
</ul>
</blockquote>
<blockquote>
<p>代理模式：接口+真实实现类+代理类</p>
</blockquote>
<blockquote>
<p>Spring里的代理模式的实现</p>
<ul>
<li>真实实现类的逻辑包含在了getBean方法里</li>
<li>getBean方法返回的实际上是Proxy的实例</li>
<li>Proxy实例是Spring采用JDK Proxy或CGLIB动态生成的、</li>
</ul>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Sail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://sailvr.github.io/2020/03/07/java/">https://sailvr.github.io/2020/03/07/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/25/interview/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>interview</span></div></a></div><div class="next-post pull_right"><a href="/2020/03/07/hello-world/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Hello World</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Sail</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>