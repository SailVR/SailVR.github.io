<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sail&#39;s Blog</title>
  
  
  <link href="https://sailvr.github.io/atom.xml" rel="self"/>
  
  <link href="https://sailvr.github.io/"/>
  <updated>2021-03-02T13:04:50.102Z</updated>
  <id>https://sailvr.github.io/</id>
  
  <author>
    <name>Sail</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>teraherz</title>
    <link href="https://sailvr.github.io/2021/03/02/teraherz/"/>
    <id>https://sailvr.github.io/2021/03/02/teraherz/</id>
    <published>2021-03-02T13:03:39.000Z</published>
    <updated>2021-03-02T13:04:50.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="太赫兹主动成像系统研究"><a href="#太赫兹主动成像系统研究" class="headerlink" title="太赫兹主动成像系统研究"></a>太赫兹主动成像系统研究</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul><li>无损的主动成像系统</li></ul><p>低频Thz：信号穿透性强但空间分辨率低</p><p>高频Thz：信号空间分辨率高但穿透性较弱</p><p>高低双波段Thz无损检测仪：图像融合技术 高分辨率与强穿透性</p><p>通过<strong>频域滤波</strong>实现干涉消除</p><p>系统：低频110.4GHz和高频220.8GHz俩个波段的本振源及超外差检测器组成。空间分辨率达3nm</p><p>结果：系统能穿透泡沫隔热材料并获得材料与金属板粘合处的二维太赫兹图像</p><ul><li>人体安检的双焦点的THz像扫描主动成像系统</li></ul><p>简单面型参数变化或成像距离的变化即可实现双焦点成像</p><p>美中不足：不能在面型中增加高次项以进一步优化成像效果</p><ul><li>双焦点反射天线格里高利成像系统</li></ul><p>系统工作频率220GHz：全视场范围内的分辨率均优于3cm</p><p>650GHz：最优点分辨率0.85cm，最差点分辨率应优于1.02cm</p><h1 id="Thz技术"><a href="#Thz技术" class="headerlink" title="Thz技术"></a>Thz技术</h1><ul><li>简介</li></ul><p>太赫兹：波长3mm到10um，频率0.1THz~10THz</p><p>低频段：电子学研究范畴</p><p>高频段：光学研究范畴</p><p>THz辐射主要特征：非破坏性、穿透性、频谱分辨特性、宽带特性</p><ul><li>产生和检测</li></ul><p><strong>THz源</strong>：任何一个温度且发射率大于零的物质都可以成为一个最简单的THz源（普朗克黑体辐射定律指出）</p><p>自由电子激光源：信号较强、覆盖的频率范围较宽，但体积较大、功耗高，在较高的功率输出的同时体积较小，只能输出低频信号</p><p>脉冲THz源：常温下获得很高的信噪比的THz信号，且频率覆盖jih8u整个THz波普范围</p><p>基于半导体的传统固态源：实验室型仪器部件</p><p><strong>THz检测器</strong></p><p>相干（外差）检测</p><p>非相干（直接）检测</p><p>（１）相干检测器能检测出的调制信号；</p><p>（２）相干检测器的噪声主要来源于本振功率波动而不是背景辐射，可以和背景辐射明显区分；</p><p>（３）和非相干检测相比，相干检测只需要很小的输入信号功率就可以检测出来更微弱的信号；</p><p>（４）相干检测器要求所有波束的极化方向，模式，直径均相同，波阵面有相同的曲率以达到好的耦合效率；</p><p>（５）目前THz源的发展还难以支撑形成大规模阵列相干检测器所需的较大本振功率的本振源。</p><ul><li>耦合与传输</li></ul><p>波导</p><p>光纤</p><p>准光系统</p><ul><li>THz系统装调测试</li></ul><p>利用THz波长远长于光波长的特点，通过借鉴光学装调方案对准光学系统装调后利用THz测试仪器微调</p><ul><li>主动成像与被动成像对比</li></ul><p>光波段：成像主要依靠物体漫反射</p><p>THz波段：成像主要依靠反射</p><ul><li>装调测试</li></ul><p>利用太赫兹波长远长于光波长的特点，通过借鉴光学装调方案对准光学系统装调后利用THz测试仪器微调</p><h2 id="双波段THz无损检测系统"><a href="#双波段THz无损检测系统" class="headerlink" title="双波段THz无损检测系统"></a>双波段THz无损检测系统</h2><p>无损检测：无损探伤</p><ul><li>THz波</li><li><ul><li>适合被检材料：非极性材料，如泡沫塑料，电介质材料，纸箱布匹等</li><li>优势：相干测量分辨折射率的微小区别；检测泡沫材料</li><li>缺陷深度不易确定</li></ul></li><li>红外波</li><li><ul><li>适合被检材料：导热性较好的材料</li><li>检测速度快，可以明确较浅的缺陷的深度</li><li>检测深度不够深</li></ul></li></ul><p><strong>无损检测原理</strong>：采用双波段太赫兹THz信号进行检测</p><p>低频太赫兹辐射具有更大的穿透性，而高频的太赫兹波可以提供更高的空间分辨率</p><p>使用相同的空间分辨率，高频的太赫兹波可以获得更长的焦深，这样成像分辨率受到缺陷深度的影响较小</p><p><strong>THz源及检测器方案</strong></p><p>THz源及检测器是双波段THz无损检测系统的核心重要组件。THz源为检测系统提供THz波，其发射功率越大，检测器接收到的能量越高（经过准光系统、大气水汽吸收及样品衰减等环节后），在其他条件同样的情况下系统获得的信噪比更高，因此更有利于缺陷的检测。</p><p><strong>双波段THz无损检测实现</strong></p><ul><li>电子学连续波THz源</li></ul><p>THz源采用本地PDRO输出低频信号后经倍频的方式实现输出</p><ul><li>准光学系统装调</li></ul><p>红外及可见光系统装调中常用的干涉法不适用于THz成像系统</p><ul><li>图像干涉法去除及融合处理</li></ul><p>基于小波分解的图像融合过程，首先对每一幅源图像进行小波变换，建立各图像的小波塔形分解。然后对各分解层分别进行融合处理，各分解层上的不同频率分量采用不同的融合算子进行融合处理，接着得到融合后的小波金字塔。最后对融合后所得的小波金字塔进行小波逆变换，所得重构图像即为融合图像</p><p>若在源与检测器的集成研制中采用同一本振信号，则可以在信号处理中引入相位信号处理，则可以进一步提高系统的分辨率及信噪比。</p><h2 id="双焦点THz主动成像系统设计"><a href="#双焦点THz主动成像系统设计" class="headerlink" title="双焦点THz主动成像系统设计"></a>双焦点THz主动成像系统设计</h2><p>采用像方扫描以减小扫描镜尺寸，实现更快速的扫描</p><h2 id="双焦点THz主动成像验证系统"><a href="#双焦点THz主动成像验证系统" class="headerlink" title="双焦点ＴＨｚ主动成像验证系统"></a>双焦点ＴＨｚ主动成像验证系统</h2><p><strong>源于检测器选型</strong></p><p>设备调试阶段：220GHz连续波THz源及直检式THz检测器</p><p>双焦点功能验证完后：650GHz连续波THz源于检测器直接替换</p><p><strong>成像系统信号处理</strong></p><p>为优化成像结果，将VDI直检式检测器如前文所述变更为外差检测器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;太赫兹主动成像系统研究&quot;&gt;&lt;a href=&quot;#太赫兹主动成像系统研究&quot; class=&quot;headerlink&quot; title=&quot;太赫兹主动成像系统研究&quot;&gt;&lt;/a&gt;太赫兹主动成像系统研究&lt;/h1&gt;&lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;head</summary>
      
    
    
    
    <category term="科研" scheme="https://sailvr.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
    <category term="太赫兹" scheme="https://sailvr.github.io/tags/%E5%A4%AA%E8%B5%AB%E5%85%B9/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sailvr.github.io/2021/01/24/hello-world/"/>
    <id>https://sailvr.github.io/2021/01/24/hello-world/</id>
    <published>2021-01-24T06:43:15.315Z</published>
    <updated>2020-03-07T04:07:39.016Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>tensorflow笔记</title>
    <link href="https://sailvr.github.io/2021/01/24/tensor/"/>
    <id>https://sailvr.github.io/2021/01/24/tensor/</id>
    <published>2021-01-24T05:09:43.000Z</published>
    <updated>2021-01-24T05:11:01.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="张量生成"><a href="#张量生成" class="headerlink" title="张量生成"></a>张量生成</h1><ul><li>创建一个张量</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = tf.constant([<span class="number">1</span>,<span class="number">5</span>],dtype=tf.int64)</span><br></pre></td></tr></table></figure></div><p>一维张量，俩个元素，1和5</p><ul><li>将numpy转为tensor</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">b = tf.convert_to_tensor(a,dtype=tf.int64)</span><br></pre></td></tr></table></figure></div><ul><li>创建一个tensor</li></ul><p>维度：一维直接写个数，二维用[行，列]，多维用[n,m,j,k…….]</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = tf.zeros([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = tf.ones(<span class="number">4</span>)</span><br><span class="line">c = tf.fill([<span class="number">2</span>,<span class="number">2</span>],<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成正太分布的随机数，默认均值为0，标准差为1</span></span><br><span class="line">d = tf.random.normal([<span class="number">2</span>,<span class="number">2</span>],mean=<span class="number">0.5</span>,stddev=<span class="number">1</span>)</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 生成截断式正太分布的随机数</span></span><br><span class="line">e = tf.random.truncated_normal([<span class="number">2</span>,<span class="number">2</span>],mean=<span class="number">0.5</span>,stddev=<span class="number">1</span>)</span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成均匀分布随机数，前闭后开区间</span></span><br><span class="line">f = tf.random.uniform([<span class="number">2</span>,<span class="number">2</span>],minval=<span class="number">1</span>,maxval=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><h1 id="TF常用函数"><a href="#TF常用函数" class="headerlink" title="TF常用函数"></a>TF常用函数</h1><ul><li>强制tensor转换为该数据类型</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1 = tf.constant([<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],dtype=tf.float64)</span><br><span class="line">print(x1)</span><br><span class="line">x2 = tf.cast(x1,tf.int32)</span><br></pre></td></tr></table></figure></div><ul><li>计算张量维度上的最小值，最大值</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(tf.reduce_max(x2))</span><br><span class="line">print(tf.reduce_min(x2))</span><br></pre></td></tr></table></figure></div><ul><li>理解axis</li></ul><p>axis = 0 纵向操作</p><p>axis = 1 横向操作</p><ul><li>tf.Variable()将变量标记为”可训练“，被标记的变量会在反向传播中记录梯度信息。神经网络训练中，常用该函数标记待训练参数</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = tf.Variable(tf.random.normal([<span class="number">2</span>,<span class="number">2</span>],mean=<span class="number">0</span>,stddev=<span class="number">1</span>))</span><br></pre></td></tr></table></figure></div><ul><li>切分传入张量的第一维度，生成输入特征/标签对，构建数据集</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">features = tf.constant([<span class="number">12</span>,<span class="number">23</span>,<span class="number">10</span>,<span class="number">17</span>])</span><br><span class="line">labels = tf.constant([<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices((features,labels))</span><br><span class="line">print(dataset)</span><br></pre></td></tr></table></figure></div><ul><li>tf.GradientTape()</li></ul><p>with结构记录计算过程，gradient求出张量的梯度</p><p>loss 函数</p><p>w 对谁求导</p><p>w2的导数是2w所以是6</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    w = tf.Variable(tf.constant(<span class="number">3.0</span>))</span><br><span class="line">    loss = tf.<span class="built_in">pow</span>(w,<span class="number">2</span>)</span><br><span class="line">grad = tape.gradient(loss,w)</span><br><span class="line">print(grad)</span><br></pre></td></tr></table></figure></div><ul><li>enumerate是python的内建函数，它可遍历每个元素（如列表，元组或字符串），组合为：索引 元素，常在for循环中使用</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,element <span class="keyword">in</span> <span class="built_in">enumerate</span>(seq):</span><br><span class="line">    print(i,element)</span><br></pre></td></tr></table></figure></div><ul><li>tf.one_hot()</li></ul><p>独热编码：在分类问题中，常用独热码做标签，标记类别：1表示是，0表示非</p><p>tf.one_hot(带转换数据，depth = 几分类)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes  = <span class="number">3</span></span><br><span class="line">labels = tf.constant([<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">output = tf.one_hot(labels,depth=classes)</span><br><span class="line">print(output)</span><br></pre></td></tr></table></figure></div><ul><li>tf.nn.softmax</li></ul><p>当n分类的n个输出通过softmax()函数，便符合概率分布了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = tf.constant([<span class="number">1.01</span>,<span class="number">2.01</span>,-<span class="number">0.66</span>])</span><br><span class="line">y_pro = tf.nn.softmax(y)</span><br><span class="line">print(<span class="string">&quot;After softmax,y_pro is&quot;</span>,y_pro)</span><br></pre></td></tr></table></figure></div><ul><li>assign_sub</li></ul><p>赋值操作，更新参数的值并返回</p><p>调用assign_sub前，先用tf.Variable定义变量w为可训练（可自更新）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w = tf.Variable(<span class="number">4</span>)</span><br><span class="line">w.assign_sub(<span class="number">1</span>)</span><br><span class="line">print(w)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></div><ul><li>tf.argmax(张量名，axis = 操作轴)  0纵向 1横向</li></ul><p>返回张量沿指定维度最大值的索引</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,[<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>]]])</span><br><span class="line">print(test)</span><br><span class="line">print(tf.argmax(test,axis=<span class="number">0</span>))</span><br><span class="line">print(tf.argmax(test,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure></div><h1 id="神经网络实现鸢尾花分类"><a href="#神经网络实现鸢尾花分类" class="headerlink" title="神经网络实现鸢尾花分类"></a>神经网络实现鸢尾花分类</h1><p>背下来</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li>tf.where(条件语句，真返回A，假返回B)</li><li>np.random.RandomState.rand(维度)</li></ul><p>返回一个[0,1)之间的随机数</p><p>维度为空，返回标量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdm = np.random.RandomState(seed=<span class="number">1</span>)</span><br><span class="line">a = rdm.rand(<span class="number">1</span>) <span class="comment"># 返回一个随机标量</span></span><br><span class="line">b = rdm.rand(<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 返回维度为2行3列的随机数矩阵</span></span><br></pre></td></tr></table></figure></div><ul><li>np.mgrid[起始值:结束值:步长 , …..]</li><li>x.ravel() 将x变为一维数组，把.前变量拉直</li><li>np.c_[数组1，数组2，…] 使返回的间隔数值点配对</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x,y = np.mgrid[<span class="number">1</span>:<span class="number">3</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">4</span>:<span class="number">0.5</span>]</span><br><span class="line">grid = np.c_[x.ravel(),y.ravel()]</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(grid)</span><br></pre></td></tr></table></figure></div><h1 id="复杂度，学习率"><a href="#复杂度，学习率" class="headerlink" title="复杂度，学习率"></a>复杂度，学习率</h1><p>时间复杂度，空间复杂度</p><p>学习率：代码每次更新的幅度</p><p>指数衰减学习率 = 初始学习率 * 学习率衰减率 ** （当前轮数/多少轮衰减一次）</p><p>lr = LR_BASE * LR_DECAY ** (epoch / LR_STEP)</p><h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><ul><li>tf.nn.sigmoid(x)</li></ul><p>易造成梯度消失</p><p>输出非0均值，收敛慢</p><p>幂运算复杂，训练时间长</p><ul><li>tf.math.tanh(x)</li></ul><p>易造成梯度消失</p><p>输出是0均值</p><p>幂运算复杂，训练时间长</p><ul><li>tf.nn.relu(x)</li></ul><p>优点：解决了梯度消失问题（在正区间）只需；判断输入是否大于0，计算速度快；收敛速度远快于sigmoid和tanh</p><p>缺点：输出非0均值，收敛慢；Dead ReIUs问题：某些神经元可能永远不会被激活，导致相应的参数永远不能被更新</p><ul><li>tf.nn.leaky_relu(x)  f(x) = max(ax,x)</li></ul><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>预测值y与已知答案y_的差距</p><ul><li>均方误差 loss_mse = tf.reduce_mean(tf.square(y_-y))</li><li>交叉熵损失函数CE 表征俩个概率分布之间的距离</li><li><ul><li>tf.losses.categorical_crossentropy(y_,y)</li></ul></li><li>softmax与交叉熵结合</li><li><ul><li>tf.nn.softmax_cross_entropy_with_logits(y_,y)</li></ul></li></ul><h1 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h1><ul><li>欠拟合的解决方法</li><li><ul><li>增加输入特征项</li><li>增加网络参数</li><li>减少正则化参数</li></ul></li><li>过拟合的解决方法</li><li><ul><li>数据清洗</li><li>增大数据集</li><li>采用正则化</li><li>增大正则化参数</li></ul></li><li>正则化缓解过拟合</li></ul><p>正则化在损失函数中引入模型复杂度指标，利用给w加权值，弱化了训练数据的噪声（一般不正则化b</p><p>loss = loss(y与y_) + REGULARIZER * loss(w)</p><p>L1正则化大概率会使很多参数变为0，因此该方法可通过稀疏参数，即减少参数的数量，降低复杂度</p><p>L2正则化会使参数很接近零但不为0，因此该方法可通过减少参数值的大小降低复杂度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">loss_mse = tf.reduce_mean(tf.square(y_train - y))</span><br><span class="line"><span class="comment"># 添加l2正则化</span></span><br><span class="line">loss_regularization = []</span><br><span class="line">loss_regularization.append(tf.nn.l2_loss(w1))</span><br><span class="line">loss_regularization.append(tf.nn.l2_loss(w2))</span><br><span class="line"><span class="comment"># 求和</span></span><br><span class="line">loss_regularization = tf.reduce_sum(loss_regularization)</span><br><span class="line"><span class="comment">#REGULARIZER = 0.03</span></span><br><span class="line">loss = loss_mse + <span class="number">0.03</span> * loss_regularization </span><br></pre></td></tr></table></figure></div><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><ul><li>SGD</li><li>SGDM，在SGD基础上增加了一阶动量</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sgd-momentun  </span></span><br><span class="line">m_w = beta * m_w + (<span class="number">1</span> - beta) * grads[<span class="number">0</span>]</span><br><span class="line">m_b = beta * m_b + (<span class="number">1</span> - beta) * grads[<span class="number">1</span>]</span><br><span class="line">w1.assign_sub(lr * m_w)</span><br><span class="line">b1.assign_sub(lr * m_b)</span><br></pre></td></tr></table></figure></div><ul><li>Adagrad</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">v_w += tf.square(grads[<span class="number">0</span>])</span><br><span class="line">v_b += tf.square(grads[<span class="number">1</span>])</span><br><span class="line">w1.assign_sub(lr * grads[<span class="number">0</span>] / tf.sqrt(v_w))</span><br><span class="line">b1.assign_sub(lr * grads[<span class="number">1</span>] / tf.sqrt(v_b))</span><br></pre></td></tr></table></figure></div><ul><li>RMSProp，SGD基础上增加了二阶动量</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">beta = <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rmsprop</span></span><br><span class="line">v_w = beta * v_w + (<span class="number">1</span> - beta) * tf.square(grads[<span class="number">0</span>])</span><br><span class="line">v_b = beta * v_b + (<span class="number">1</span> - beta) * tf.square(grads[<span class="number">1</span>])</span><br><span class="line">w1.assign_sub(lr * grads[<span class="number">0</span>] / tf.sqrt(v_w))</span><br><span class="line">b1.assign_sub(lr * grads[<span class="number">1</span>] / tf.sqrt(v_b))</span><br></pre></td></tr></table></figure></div><ul><li>Adam</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   m_w, m_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">   v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">   beta1, beta2 = <span class="number">0.9</span>, <span class="number">0.999</span></span><br><span class="line"><span class="comment"># adam</span></span><br><span class="line">   m_w = beta1 * m_w + (<span class="number">1</span> - beta1) * grads[<span class="number">0</span>]</span><br><span class="line">   m_b = beta1 * m_b + (<span class="number">1</span> - beta1) * grads[<span class="number">1</span>]</span><br><span class="line">   v_w = beta2 * v_w + (<span class="number">1</span> - beta2) * tf.square(grads[<span class="number">0</span>])</span><br><span class="line">   v_b = beta2 * v_b + (<span class="number">1</span> - beta2) * tf.square(grads[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">   m_w_correction = m_w / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta1, <span class="built_in">int</span>(global_step)))</span><br><span class="line">   m_b_correction = m_b / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta1, <span class="built_in">int</span>(global_step)))</span><br><span class="line">   v_w_correction = v_w / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta2, <span class="built_in">int</span>(global_step)))</span><br><span class="line">   v_b_correction = v_b / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta2, <span class="built_in">int</span>(global_step)))</span><br><span class="line"></span><br><span class="line">   w1.assign_sub(lr * m_w_correction / tf.sqrt(v_w_correction))</span><br><span class="line">   b1.assign_sub(lr * m_b_correction / tf.sqrt(v_b_correction))</span><br></pre></td></tr></table></figure></div><h1 id="搭建网络八股sequential"><a href="#搭建网络八股sequential" class="headerlink" title="搭建网络八股sequential"></a>搭建网络八股sequential</h1><ul><li>第一步：import相关模块，如import tensorflow as tf</li><li>第二步：指定输入网络的训练集和测试集，如指定训练集的输入x_train和标签y_train，测试集的输入x_test和标签y_test。</li><li>第三步：逐层搭建网络结构，model = tf.keras.models.Sequential()。</li><li>第四步：在model.compile()中配置训练方法，选择训练时使用的优化器、损失函数和最终评价指标。</li><li>第五步：在model.fit()中执行训练过程，告知训练集和测试集的输入值和标签、每个batch的大小（batchsize）和数据集的迭代次数（epoch）</li><li>第六步：使用model.summary()打印网络结构，统计参数数目。</li></ul><h1 id="搭建Model"><a href="#搭建Model" class="headerlink" title="搭建Model"></a>搭建Model</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IrisModel</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(IrisModel,self).__init__()</span><br><span class="line">        self.d1 = Dense(<span class="number">3</span>,activation=<span class="string">&#x27;sigmoid&#x27;</span>,kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        y = self.d1(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = IrisModel()</span><br></pre></td></tr></table></figure></div><h1 id="断点续训"><a href="#断点续训" class="headerlink" title="断点续训"></a>断点续训</h1><p>load_weights(路径中文名) 读取模型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/mnist.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=<span class="literal">True</span>,</span><br><span class="line">                                                 save_best_only=<span class="literal">True</span>)</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br></pre></td></tr></table></figure></div><h1 id="参数提取"><a href="#参数提取" class="headerlink" title="参数提取"></a>参数提取</h1><p>model.trainable_variables 返回模型中可训练的参数</p><p>设置print输出格式</p><p>np.set_printoptions(threshold=超过多少省略显示)</p><p>np.set_printoptions(threshold=np.inf)  # np.inf表示无限大</p><h1 id="acc与loss"><a href="#acc与loss" class="headerlink" title="acc与loss"></a>acc与loss</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示训练集和验证集的acc和loss曲线</span></span><br><span class="line">acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(loss, label=<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss, label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><p>输入特征值的深度（channel数），决定了当前层卷积核的深度</p><p>当前层卷积核的个数，决定了当前层输出特征图的深度</p><h1 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h1><p>卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小</p><h1 id="全零填充"><a href="#全零填充" class="headerlink" title="全零填充"></a>全零填充</h1><p>为了保持输出图像尺寸与输入图像一致，经常会在输入图像周围进行全零填充</p><p>在Tensorflow框架中，用参数padding = ‘SAME’或padding = ‘VALID’表示是否进行全零填充</p><h1 id="TF描述"><a href="#TF描述" class="headerlink" title="TF描述"></a>TF描述</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.layers.Conv2D(</span><br><span class="line">input_shape = (高, 宽, 通道数), <span class="comment">#仅在第一层有</span></span><br><span class="line">filters = 卷积核个数,</span><br><span class="line">kernel_size = 卷积核尺寸,</span><br><span class="line">strides = 卷积步长,</span><br><span class="line">padding = ‘SAME’ <span class="keyword">or</span> ‘VALID’,</span><br><span class="line">activation = ‘relu’ <span class="keyword">or</span> ‘sigmoid’ <span class="keyword">or</span> ‘tanh’ <span class="keyword">or</span> ‘softmax’等</span><br><span class="line">    <span class="comment">#如有BN则此处不用写</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="BN层"><a href="#BN层" class="headerlink" title="BN层"></a>BN层</h1><p>Batch Normalization将神经网络每层的输入都调整到均值为0，方差为1的标准正态分布，其目的是解决神经网络中梯度消失的问题</p><p>BN操作的另一个重要步骤是缩放和偏移，值得注意的是，缩放因子γ以及偏移因子β都是可训练参数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.layers.BatchNormalization()</span><br></pre></td></tr></table></figure></div><h1 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h1><p>池化的作用是减少特征数量（降维）。最大值池化可提取图片纹理，均值池化可保留背景特征</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.layers.MaxPool2D(</span><br><span class="line">pool_size = 池化核尺寸,</span><br><span class="line">strides = 池化步长,</span><br><span class="line">padding = ‘SAME’ <span class="keyword">or</span> ‘VALID’</span><br><span class="line">)</span><br><span class="line">tf.keras.layers.AveragePooling2D(</span><br><span class="line">pool_size = 池化核尺寸,</span><br><span class="line">strides = 池化步长,</span><br><span class="line">padding = ‘SAME’ <span class="keyword">or</span> ‘VALID’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="舍弃"><a href="#舍弃" class="headerlink" title="舍弃"></a>舍弃</h1><p>在神经网络的训练过程中，将一部分神经元按照一定概率从神经网络中暂时舍弃，使用时被舍弃的神经元恢复链接</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.layers.Dropout(<span class="number">0.2</span>)   <span class="comment">#dropout</span></span><br></pre></td></tr></table></figure></div><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>参数时间共享，循环层提取时间信息</p><p>循环神经网络：借助循环核提取时间特征后，送入全连接网络</p><p>循环计算层：向输出方向生长</p><p>return_sequences = False 循环核仅在最后一刻输出ht</p><p>Embedding：一种单词编码方法，用低维向量实现了编码。这种编码通过神经网络训练优化，能表达出单词间的相关性s</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;张量生成&quot;&gt;&lt;a href=&quot;#张量生成&quot; class=&quot;headerlink&quot; title=&quot;张量生成&quot;&gt;&lt;/a&gt;张量生成&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;创建一个张量&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class</summary>
      
    
    
    
    <category term="实习" scheme="https://sailvr.github.io/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
    <category term="神经网络" scheme="https://sailvr.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>20考研总结</title>
    <link href="https://sailvr.github.io/2020/05/29/%E8%80%83%E7%A0%94%E6%80%BB%E7%BB%93/"/>
    <id>https://sailvr.github.io/2020/05/29/%E8%80%83%E7%A0%94%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-29T07:16:35.000Z</published>
    <updated>2021-01-24T11:17:05.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><p>本人毕业于北京交通大学计算机科学与技术专业2016级</p><p>报考学校、初试分数：北京大学 电子信息（智能科技） 初试分335  复试线350 其中政治71英一67数一84专业课113</p><p>调剂拟录取：兰州大学信息学院电子信息（计算机方向）、东南大学苏州联合研究院电子信息（健康数据科学）、中国科学院大学上海微系统与信息技术研究所电子信息</p><p>最终去向：中科院上海微系统与信息技术研究所</p><h1 id="复习情况"><a href="#复习情况" class="headerlink" title="复习情况"></a>复习情况</h1><p>大三下开始买书复习，但是零零散散，等于没复习。专业课程实在太多，没办法。暑假开始与鹏哥一起复习，小学期的课我是拿之前的竞赛水完了。暑期过完数学一轮，背完基本的考研单词，随便看点政治，暑期后进行强化，刷卷子等。（最后鹏哥380上岸帝都交通大学，我却没考上。。）</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>我数一太差，84分，就写个失败教训吧！</p><p>数学题一定要认认真真的思考再作答，另外，考研数学题风格变化大，不要以为这个不考，每年变化挺大的，17及以前（除了16）的卷子难度真的没有参考价值，但是有的题型可能会翻出来搞个增强版出，所以得注意。数学真题参考价值我个人觉得不大，主要是我当初对于很多老师的模拟卷，有的不会我可能就以为考试不考，就没太在意，感觉跟真题风格差距很大，结果20真题风格又变了。所以数学一定要无死角复习，花一半时间在数学上都不为过，得数学者赢考研。</p><h2 id="专业课（DS，OS，网络）"><a href="#专业课（DS，OS，网络）" class="headerlink" title="专业课（DS，OS，网络）"></a>专业课（DS，OS，网络）</h2><p>专业课113分，中游水平。。。（大佬太多，我尽力了）</p><p>暑假我就开始看专业课，毕竟是三门。王道天勤的专业课我都买了，软微的题型就是要你认认真真的掌握其中的概念，不考手撕代码题，今年计网考了TCP分析的，但是没有给你TCP表就有点坑。。</p><p>认认真真做好王道就行了，感觉天勤没啥必要。把里面的细致的概念做好</p><h2 id="英一"><a href="#英一" class="headerlink" title="英一"></a>英一</h2><p>英一我是67分，考的一般。其中阅读的text2我错了四个，emmm，今年英一偏简单，但是还是考的不好。我的复习是这样的：</p><p>大三下学期就是背背扇贝单词，看看恋恋有词这本书</p><p>暑期的时候没做真题，就是做一些模拟题，但是发现自己错了好多，而且根本读不懂，什么政治，什么经济，连做五篇阅读，大概错八到十个，很难受的。后来掌握套路，背单词不要只背单词，要带入相应的句子进行联想背诵，这样就能大致知道单词的用法，以及在不同语境下表达的意思是如何的。得阅读得天下，其他不用太认真准备，个人觉得英一能考70是完全不会被拉分的也不影响上岸的。</p><p>暑期后期，到八月底左右，我是开始做英语真题的，从2000年开始做，2005年前的题型不一样，也可以不做。2005后的，就要非常认真仔细的做，建议一次性五篇连做，当然你也可以先拿10年以前的练手，然后10以后的五篇连做。个别年的比较难，心态不要炸。我当初自认为水平还可以，10及以后的，我只有一年错了五个，其他都是2-4个，所以我觉得我英一应该稳了。没想到英一阅读貌似错了6-7个，难受。</p><p>关于作文翻译，其实吧，北京地区大家都差不多，随便背点，考场直接用就行了，影响不大，与其花在这里，还不如多刷会数学题（心痛）当初我还看了唐静的翻译还有刘晓静的作文，实在是，emm，背一篇大致的模板，考试还是得自己灵活运用的，千万不要用老掉牙的模板！！！</p><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>政治的复习应该是比较轻松的，我的成绩是71，复查图我找不到了，我选择题是42分，大题是29分。</p><p>暑期就一直看徐涛的强化班就行了，一天半小时或者到一小时，看自己安排，一定要在自己累得时候看，因为萌涛挺搞笑的，考研前也要多喝旺仔牛奶，容易政治考高分。</p><p>我买的政治书是徐涛的书基本都买了，徐涛八套卷我没买，什么优题库，还有小黄书（然而没背）时政的（然而没看）九月就一直刷政治微信小程序选择题就行了，刷完一遍再刷一遍，我找了好几个小程序，天天刷，晚上回宿舍也能刷。后期建议买个肖四就行了（肖八我就做了选择题，其他都没看）然而所有老师的政治选择题在某个微信小程序都有卖，价格只需9.9或者19.9，我觉得这个性价比更高。考前俩个星期，背肖四就行了，有人问一定要全背完吗，其实是不要的，今年肖四真的神押题，基本一题没中，就中了个是个人都能猜中的新中国70周年（我惊了）然后开启胡扯模式，不过也用到了肖四背的，如果大家背不完，滚瓜烂熟第一套就行了，大题差距不大，选择题才是重点哦（建议刷微信小程序）</p><p>关于手机呢，大家可以不带手机，用ipad来刷题，大屏看的更爽。</p><h1 id="调剂"><a href="#调剂" class="headerlink" title="调剂"></a>调剂</h1><p>关于调剂，大家去我另一个博客<a href="https://sailvr.github.io/2020/05/25/interview/">20考研调剂记录</a></p><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><p>1：<strong>政治疯狂刷选择题</strong>就行了！各种微信小程序刷起来，大题只背肖四就行了（只背一套也可以）如果你想考80分并且数学已经稳了的话，那你好好做政治大题。</p><p>2：<strong>英一好好做阅读</strong>，掌握20年真题阅读里的所有单词怎么用，最好是把真题阅读都读熟，得阅读得天下。如果你数学稳了话，中途可以认真准备作文翻译等。。英语只需要做好真题就行了</p><p>3：<strong>数学就是多刷题</strong>，一定要自己做完再对。数学真题真的无法满足你，各种你觉得怪的也最好无死角掌握，现在数学变化太大。明年由于疫情还会扩招，难度估计会简单点吧。</p><p>4：专业课看学校复习，祝好！</p><h1 id="报考院校推荐"><a href="#报考院校推荐" class="headerlink" title="报考院校推荐"></a>报考院校推荐</h1><p>关于计算机考研报考院校推荐（反正我不怕炸，又不是我考）</p><p><strong>Top2</strong>：不推荐，实在是太难了，今年清深调剂比较多，貌似有点捡漏，但是清华卷子太难了简直巨难，考得不好调剂都没戏，从调剂角度来说，北大软微是最友好的。今年北大软微还能调剂信科，物理，工学院呢，前提是350+</p><p><strong>C9</strong>：西交不是很了解，从来没考虑过去西北，听说西交软件招四百多人，在创新港校区，考的数二英二数据结构，估计不难。哈工大19年比较难，20年又101%复录比，哈工威兜底，分数线低，今年又说不准了。华东五校，今年复旦超级捡漏明年说不准，去年复旦是爆炸的。上交别考虑了，年年炸啊（考上交还不如考中科大，一样的卷子），浙大今年稍微简单点，南大计算机难，软件分数也高了（我同学350初试150名招140多没上岸）最推荐报考的就是中科大了，中科大计算机学院难度可能比较大，但是年年都有其他学院兜底，还有中科大一些研究所，发的也是中科大学历，今年先研院300上岸大量调剂（都是校内），中科大明年就算炸（我觉得不可能）也不会太难，比考上交浙大南大简单多了，复旦计算机实力较差（去年难今年捡漏，明年说不准）</p><p><strong>上九</strong>：难度都大，北京高校可以考虑北京理工，专硕只考数据结构。武大今年是捡漏的，因为第一年改考，但是去年是很难得。武大网安今年收大量校外调剂，据说有个二本的调剂去了武大。华科就算了，难度较大。同济计算机也难考，招人还少，最头疼的是，别人在官网公布拟不录取名单。。。</p><p><strong>中九</strong>：推荐厦门大学、东南大学，厦大和东南都有兜底的（一定要考数一英一，因为只有数一英一才能调剂），考不上还能调剂。尤其东南大学，考不上还能调剂东蒙。东南苏软今年200校外调剂，明年可以考虑。本人推荐一志愿计算机学院，毕竟本部才是正宗，考不上就去调剂东蒙就行了。（氪金15w，绝对一直收调剂！！）另外，推荐华东师范大学，他的软件工程评估A，学科实力强还在大上海，难度较低，比较好考，就业在上海是不差的，还有985牌子</p><p><strong>末九</strong>：我认为北交学生是看不上的，跳过</p><p><strong>211：</strong>推荐北交计算机专硕，点击就送，10:1报录比又怎样，你是本校的，怕谁！如果大家是考北交的话，虽然简单，但是也别作死了，计算机学硕351分，难度比较大，专硕315分，基本点击就送。如果你想科研并且成绩尚可，一定要好好复习，到时候联系本校导师，也能去好的实验室。如果你仅仅只想水个学历，最后毕业去大厂开发，我个人建议读专硕，找个特别佛系的导师，然后研二就吭哧吭哧的去实习了（太香了）</p><p><strong>中科院</strong>：计算所和自动化所就别考虑了，你就算考上了找的导师也不好。软件所比北交稍微强一点，但是难度不是差一点，大家好好考虑。至于信工所，我觉得不如北交哈哈哈。毕竟是科研院所嘛，我觉得你可以考虑中科院其他所，难度较低，但是含金量可能差点。比如中科院上微所（我去的学校）明年收不收调剂不一定了，今年是疫情原因扩招收专硕调剂，学硕一志愿都满了，只有与上科联培的还有学硕名额（发上科大学位证毕业证）中科院的专业课卷子有点难哎，还不如考中科大呢，就算考研失败，调剂去的中科大的研究所还有985牌子！（中科大研究所基本只收校内调剂）</p><p>以上的经验不一定适合所有人，大家要结合自身的情况，选择性地吸收，要有一套符合自己的复习计划。祝大家成功上岸！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本情况&quot;&gt;&lt;a href=&quot;#基本情况&quot; class=&quot;headerlink&quot; title=&quot;基本情况&quot;&gt;&lt;/a&gt;基本情况&lt;/h1&gt;&lt;p&gt;本人毕业于北京交通大学计算机科学与技术专业2016级&lt;/p&gt;
&lt;p&gt;报考学校、初试分数：北京大学 电子信息（智能科技） 初试</summary>
      
    
    
    
    <category term="20考研" scheme="https://sailvr.github.io/categories/20%E8%80%83%E7%A0%94/"/>
    
    
    <category term="20考研" scheme="https://sailvr.github.io/tags/20%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>东蒙553读程序题2019</title>
    <link href="https://sailvr.github.io/2020/05/26/%E4%B8%9C%E8%92%99553%E8%AF%BB%E7%A8%8B%E5%BA%8F%E9%A2%982019/"/>
    <id>https://sailvr.github.io/2020/05/26/%E4%B8%9C%E8%92%99553%E8%AF%BB%E7%A8%8B%E5%BA%8F%E9%A2%982019/</id>
    <published>2020-05-26T08:03:45.000Z</published>
    <updated>2020-05-26T09:18:11.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[<span class="number">-1</span>] + a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">func(&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">26</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">43</span></span><br><span class="line"><span class="comment">53</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><p>a[0]当前地址，a[1]下一个地址，a[-1]是前一个地址</p><p>首先调用func(&amp;a[1]);就是将数组的第二位（第一位是a[0]）改成前一个与后一个相加，所以是1+3 = 4</p><p>然后整个数组变为{ 1, 4, 3, 4, 5, 6, 7, 8, 9, 10};然后访问数字3，改为4+4 = 8，依次循环下去，数组改为</p><p>{1,4,8,13,19,26,34,43,53,10}</p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">b[i] += a[i][a[j][i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出 </span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b) c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) c = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ++d + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">2</span>, y=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; func(x++, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">x = y + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">3,3,3</span></span><br><span class="line"><span class="comment">5,3,6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><p>首先最先开始输出的x不是2，是3，因为程序执行优先执行函数，所以函数中x++了，变成3了，所以。。</p><p>先看函数，x是2，y是3（x++和++x的区别）</p><p>其中static int d是静态变量，只会调用一次！</p><p>a是2，b是3，c是0，d是3</p><p>a&lt;b，所以c=-1</p><p>然后++d立马修改d，变成4，加上-1，返回值就是3</p><p>最后输出3,3,3</p><p>然后x = y+1，x改成4</p><p>进入第二轮循环，还是先执行函数传入x=4，y=3，即a=4,b=3，c=0，d=4（不是3，因为是静态变量）</p><p>a&gt;b,所以c=1，然后++d编程5再+1返回6</p><p>所以输出5,3,6</p><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (*str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;abc8d0e32fg\0hi1k3&quot;</span>;</span><br><span class="line">func(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出4</span></span><br></pre></td></tr></table></figure></div><p>\0表示字符串结束了，后面就不读了</p><p>大家可以在count++前面加上cout&lt;&lt;*str&lt;&lt;endl;可以看出输出是8 0 3 2 4（这个4是count）</p><h1 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A0</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;D::print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A0 *p; B b; D d;</span><br><span class="line">p = &amp;d; p-&gt;print();</span><br><span class="line">p = &amp;b; p-&gt;print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">D::print</span></span><br><span class="line"><span class="comment">B::print</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><p>就算不懂虚函数，这题也能猜出来这么写。。。</p><p>虚函数听着NB，实际上跟java里面的abstract方法貌似没啥区别，目的就是为了实现多态，父类定义一个不实现的函数，子类去具体的实现，更官方的说法就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。</p><h1 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student +&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">        ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;- Student&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Teacher() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Teacher +&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">~Teacher() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;- Teacher&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Student stu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Teacher t; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Student +</span></span><br><span class="line"><span class="comment">Teacher +</span></span><br><span class="line"><span class="comment">- Teacher</span></span><br><span class="line"><span class="comment">- Student</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><p>程序的执行实际是个栈，所以先执行构造，再执行析构，先入S，再入T，所以回收，就是先出T，再出S，栈的顺序是STTS</p><p>为什么先S再T？（看第一个）</p><p>C++构造函数调用顺序</p><ol><li>如果类里面有成员类，成员类的构造函数优先被调用；</li><li>创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；</li><li>基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；</li><li>成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；</li><li>派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight-tools&quot;&gt;&lt;i class=&quot;fa</summary>
      
    
    
    
    <category term="20考研" scheme="https://sailvr.github.io/categories/20%E8%80%83%E7%A0%94/"/>
    
    
    <category term="20考研" scheme="https://sailvr.github.io/tags/20%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>招银网络科技java岗校招面经</title>
    <link href="https://sailvr.github.io/2020/05/26/zhaoyin/"/>
    <id>https://sailvr.github.io/2020/05/26/zhaoyin/</id>
    <published>2020-05-26T03:22:23.000Z</published>
    <updated>2020-05-26T03:24:26.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一面（30分钟）"><a href="#一面（30分钟）" class="headerlink" title="一面（30分钟）"></a>一面（30分钟）</h1><p>  java </p><p>  java泛型 </p><p>  java封装继承多态 </p><p>  java多线程同步锁 </p><p>  手撕代码： </p><p>  1 java匿名内部类 </p><p>  2 匿波兰表达式 </p><p>  数据库 </p><p>  1 ACID </p><p>  2 电脑突然关机了，开机后数据还在，属于哪个性质？ </p><p>  3 数据库锁，隔离级别 </p><p>  你还有什么其他问题？ </p><h1 id="二面（没有手撕代码哦）"><a href="#二面（没有手撕代码哦）" class="headerlink" title="二面（没有手撕代码哦）"></a>二面（没有手撕代码哦）</h1><p>  介绍项目，针对项目各种盘（还好我说的是区块链，各种扯） </p><p>  一万个数据，如何取前k个 </p><p>  具体怎么优化，难道从头到尾遍历 </p><p>  字符串如何逆序输出？ </p><p>  字符串如何逆序输出单词，单词内部不逆序，比如I am a studuent输出student a am I </p><p>  jvm哪些区，具体是啥功能? </p><p>  string 和new string啥区别？ </p><p>  又追问：他们各自创建几个对象，可以多个吗？ </p><p>  你有什么问题？ </p><p>  不要退出房间，等会hr面 </p><h1 id="三面（hr面）"><a href="#三面（hr面）" class="headerlink" title="三面（hr面）"></a>三面（hr面）</h1><p>  家庭情况 </p><p>  个人求职意向（工作地点，加班啥的） </p><p>  个人项目经验 </p><p>  本科最成就的事 </p><p>  你拿到啥offer了没？请比较下，为什么你不去？为什么你想来招行 </p><p>  大厂你面试过了没？啥情况啊 </p><p>  你没参加秋招吗? </p><p>  你对深造没有意向吗？ </p><p>  你有啥实习经历？ </p><p>  你本科成绩咋样啊？ </p><p>  等等其他问题 </p><p>  hr说一到俩周出结果 </p><p>  更新： </p><p>  4.4 面试表现的我觉得是可以的。但是没有收到offer信息，有人收到了，我觉得基本凉了。 </p><p>  可能是因为我是本科生的原因？？？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一面（30分钟）&quot;&gt;&lt;a href=&quot;#一面（30分钟）&quot; class=&quot;headerlink&quot; title=&quot;一面（30分钟）&quot;&gt;&lt;/a&gt;一面（30分钟）&lt;/h1&gt;&lt;p&gt;  java &lt;/p&gt;
&lt;p&gt;  java泛型 &lt;/p&gt;
&lt;p&gt;  java封装继承多态 &lt;</summary>
      
    
    
    
    <category term="校招" scheme="https://sailvr.github.io/categories/%E6%A0%A1%E6%8B%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>深信服测试校招offer面经</title>
    <link href="https://sailvr.github.io/2020/05/26/shenxinfu/"/>
    <id>https://sailvr.github.io/2020/05/26/shenxinfu/</id>
    <published>2020-05-26T03:04:39.000Z</published>
    <updated>2020-05-26T03:23:14.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>  进程线程区别？ </p><p>  java内进程线程怎么存的？（jvm） </p><p>  java修饰器你知道哪些？ </p><p>  java多线程如何实现的？ </p><p>  java vector和list什么区别？ </p><p>  还有其他基础问题，不记得了 </p><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>  介绍项目。。 </p><p>  你对你的项目溯源部分是怎么测试的 </p><p>  你对你的项目服务器网盘，假如我们访问速度比较慢，你会怎么测试？ </p><p>  cookie从哪来的 </p><p>  浏览器端输入百度的地址，然后会发生什么？ </p><p>  手撕代码：IP地址合并<a href="https://www.nowcoder.com/questionTerminal/212c0df2ecaf4d73898a0dfa1a56c3fc?orderByHotValue=1&amp;page=1&amp;onlyReference=false">https://www.nowcoder.com/questionTerminal/212c0df2ecaf4d73898a0dfa1a56c3fc?orderByHotValue=1&amp;page=1&amp;onlyReference=false</a>  </p><p>  你对测试的理解？ </p><p>  总结：除了手撕代码稍微难点外，其他都很基础。面了35分钟，大部分是针对项目问的</p><h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>  三面hr（3.10），没有问到技术方面的</p><p>  自我介绍 </p><p>  问问兴趣爱好啥的 </p><p>  你对测试的理解 </p><p>  你在大学一天的作息怎样 </p><p>  你从懂事开始遇到最大的困难是什么 </p><p>  从你的某个项目某个点说起，说说你是怎么看待的，并且你是怎么相对别人有优势的 </p><p>  你在测试方面相对别人有什么优势 </p><p>  你对深信服的了解如何 </p><p>  网上对深信服加班有点诟病，你是怎么看待的？（我觉得加班没有任何问题，年轻人就应该奋斗！） </p><p>  你目前收到其他offer了吗？具体是什么工作的 </p><p>  你对薪资的要求是怎样的 </p><p>  等等其他问题 </p><p>  面试官问我有木有什么问题，我问了下测试应届生的发展前景如何？hr回答挺多的，总结起来就是一个字：好！ </p><p>  最后hr还给了我联系方式？说一周内通知  </p><p>  中途我网还断了一次，跟hr重连了，尴尬！ </p><p>  希望能拿offer </p><p>  更新：今早九点（3.13）收到offer资源池信息。。  </p><p>  今天3.17正式收到offer</p><p>深信服的开价是13.2k一个月，年终奖1到3个月工资，提供三个月酒店住宿，包吃</p><p>但是加班方面是周二周四晚上加班到十点左右，每个月的第一个周六早上加班</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h1&gt;&lt;p&gt;  进程线程区别？ &lt;/p&gt;
&lt;p&gt;  java内进程线程怎么存的？（jvm） &lt;/p&gt;
&lt;p&gt;  java修饰器你知道哪些？ &lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="校招" scheme="https://sailvr.github.io/categories/%E6%A0%A1%E6%8B%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>美团测开校招offer面经</title>
    <link href="https://sailvr.github.io/2020/05/26/meituan/"/>
    <id>https://sailvr.github.io/2020/05/26/meituan/</id>
    <published>2020-05-26T02:52:46.000Z</published>
    <updated>2020-05-26T03:23:08.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-23一面"><a href="#3-23一面" class="headerlink" title="3.23一面"></a>3.23一面</h1><p>   美团测开面试了整整一个小时，真的太疲倦了  </p><p>   自我介绍+项目经验  </p><p>   测试方法，测试框架你了解啥  </p><p>   linux指令你了解啥  </p><p>   手撕代码：括号匹配  </p><p>   linux指令你知道些啥？  </p><p>   linux查找文件中的某个字符，并复制到另一个文件怎么做  </p><p>   linux文件替换某个字符是什么指令  </p><p>   微信红包功能该怎么测试  </p><p>   你有实习过吗？  </p><p>   数据库：查找平均分大于60的同学  </p><p>   查找平均分前五名的同学</p><p>   一万多个数据，无序的，我怎么才能快速查找到我想要的一个数据（我说B+数，最左前缀匹配，还不知道对不对）  </p><p>   java多线程：线程安全怎么理解？start和run区别？  </p><p>   String是引用类型还是基本类型？引用类型和基本类型的区别？  </p><p>   StringBuild和StringBuffer区别？  </p><p>   java多态怎么理解？底层实现是啥?  </p><p>   jvm栈和堆的区别？java对象的属性放在哪？  </p><p>   java框架你了解啥？  </p><p>   为什么做测试  </p><p>   你对测开理解  </p><p>   你再社团上干了啥  </p><p>   如果社团、学习冲突你会怎么解决  </p><p>   你还有什么问题  </p><h1 id="3-25二面"><a href="#3-25二面" class="headerlink" title="3.25二面"></a>3.25二面</h1><p>  又整整一个小时，疲倦 </p><p>  前面一直聊本科项目啥的，自己做过啥，自己实习经历啥的 </p><p>  手撕代码开始了：剪绳子（动态规划）在线提交运行（一遍过） </p><p>  面试官准备出一道在线笔试题的一道让我写，我立马否决，那还是剪绳子吧！ </p><p>  你做过剪绳子？没有没有，我看看 </p><p>  简单说一说jvm </p><p>  智力题：俩个瓶子，100m高，如何测出可承受的高度，什么方法？ </p><p>  你还投过其他大厂没？ </p><p>  大部分都是聊项目，大学经历，兴趣爱好啥的，各种扯😂😂  </p><p>  最后说之后hr面    </p><p>  更新：3.30电话三面hr面，30min左右，就聊了下本科的经历，社团，项目啥的  </p><p>  4.9终于收割了offer，白菜价。当时hr面说低了，我说我期望16k，最后开了17K*15.5月（本科生）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-23一面&quot;&gt;&lt;a href=&quot;#3-23一面&quot; class=&quot;headerlink&quot; title=&quot;3.23一面&quot;&gt;&lt;/a&gt;3.23一面&lt;/h1&gt;&lt;p&gt;   美团测开面试了整整一个小时，真的太疲倦了  &lt;/p&gt;
&lt;p&gt;   自我介绍+项目经验  &lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="校招" scheme="https://sailvr.github.io/categories/%E6%A0%A1%E6%8B%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>20考研调剂记录</title>
    <link href="https://sailvr.github.io/2020/05/25/interview/"/>
    <id>https://sailvr.github.io/2020/05/25/interview/</id>
    <published>2020-05-25T08:06:42.000Z</published>
    <updated>2020-05-29T05:15:45.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="兰大15min计算机专硕调剂面试"><a href="#兰大15min计算机专硕调剂面试" class="headerlink" title="兰大15min计算机专硕调剂面试"></a>兰大15min计算机专硕调剂面试</h1><p>首先说老师们好，然后老师叫你出示准考证和身份证，然后15分钟问问题开始了<br>没有自我介绍+个人项目介绍的环节，从头到尾都是question<br>抽题：为什么自然语言处理比计算机视觉更难做？<br>第一个老师：C语言如何定义长度为5的整形数组？然后问如何定义一万亿的？<br>第二个老师：网路层的作用是啥？路由协议选一个说说？详细说明OSPF？<br>第三个老师：离散数学三段式是啥？体系结构流水线执行几个阶段？流水线的作用？<br>第四个老师：进程线程区别是啥？详细说明TCP三次握手？<br>第五个老师（英文）：你如何看待研究？你未来学习规划？</p><h1 id="上科25min项目型学硕计科调剂面试"><a href="#上科25min项目型学硕计科调剂面试" class="headerlink" title="上科25min项目型学硕计科调剂面试"></a>上科25min项目型学硕计科调剂面试</h1><p>你本科专业是啥？一志愿哪的？一志愿考了啥？（DS，OS，网络）<br>首先英文自我介绍<br>快排原理是什么？快排pivos怎么选，一定是第一个吗？选最后一个行不行？<br>   随机选个行不行？什么情况时间复杂度最大？为什么？<br>操作系统文件概念是什么？文件是物理的还是虚拟的？<br>操作系统getpid，printpid，fork，getpid，printpid打印了几个进程？为什么？<br>解释下stack和heap区别（英文）<br>解释下操作系统的mutex（英文）<br>还问了个上下文内存啥的，我就听到个memory（英文）然后我直接说不会<br>比特币原理是啥？（项目）<br>LSTM解释下，跟rnn区别是啥？（项目）<br>小程序和APP区别是啥？（项目）<br>智能聊天项目你用了啥（项目）没用到什么神经网络吗？<br>你在github上开源了啥？github你是怎么理解的？<br>git是什么？git风险是啥？</p><h1 id="南科大计算机系15min调剂面试"><a href="#南科大计算机系15min调剂面试" class="headerlink" title="南科大计算机系15min调剂面试"></a>南科大计算机系15min调剂面试</h1><p>跟导师关系不好怎么办，自己的文章发表不出影响毕业怎么办？（英文）<br>非监督学习和监督学习的区别？过拟合什么情况？怎么样防止过拟合？<br>解释区块链原理？如何生成新的区块？你是怎么做的？<br>CNN和RNN的区别？LSTM？<br>路线规划，你来做，你会采用什么算法？</p><h1 id="微系统所10min计科学硕调剂面试"><a href="#微系统所10min计科学硕调剂面试" class="headerlink" title="微系统所10min计科学硕调剂面试"></a>微系统所10min计科学硕调剂面试</h1><p>英文自我介绍</p><p>你了解5G技术吗</p><p>你觉得计算机技术在机器人和自动化方面是如何？</p><p>介绍项目：聊天机器人，知识图谱你是怎么训练的？</p><p>人体行为识别你是怎么整的？特征你是怎么抽取的？</p><p>你用的主要编程语言是啥？代码量如何？</p><h1 id="东蒙20min03方向健康数据科学面试"><a href="#东蒙20min03方向健康数据科学面试" class="headerlink" title="东蒙20min03方向健康数据科学面试"></a>东蒙20min03方向健康数据科学面试</h1><p>英文讲述PPT（全英文，个别不会说的可以中文说）</p><p>抽题：第一题不会，什么10，选择题，什么110啥的，看不懂</p><p>第二题：忘了，是很简单的问题</p><p>二维图像和RNN什么应用啥的，听的不是很清楚？</p><p>如果你看到一个论文，和你搭建的模型结果不匹配，你会怎么做？</p><p>为什么选择健康数据科学方向？</p><p>你是怎么做的人体行为识别？</p><p>人工智能和机器学习的目的是啥？</p><h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p><strong>拟录取：兰州大学，东南大学，中科院微系统所</strong></p><p><strong>我的选择：中科院微系统所</strong></p><p>选择原因：兰州大学比较偏，东南大学学费贵，做生物医学的</p><p>至于微系统所，我来宣传下：研一中科大，研二研三上海长宁（我做的方向是在长宁）</p><p>1.微系统所属于国科大的科教融合学院，学籍国科大，双证国科大。合肥中科大代培。<br>2.与上大，上科大联培的学生学籍上大，上科大，双证上大，上科大。研一上大上科大学习，研二以后来所学习。<br>3.所里可能有国科大微电子学院和国科大杭州高等研究院调剂名额，学籍国科大，研一北京国科大学习。<br>4.所里就业基本等同于华五水平。自14年国科大招收本科生以来，生源水平以及就业质量均不断提高，出路以各大企业为主，留所以及其他机关和企事业单位均可。</p><p>除此之外<br>1、对于中科院不是985的问题。如果很在意985请考虑大学。但是就业时中科院都是等同985看待的。<br>2、考研/推免。最近几年不管是考研还是推免性价比很高。同等档次的高校我们相对比较好考，同等难度的高校相比，我们名气和实力更大，所以请各位认真考虑我们所。<br>3、待遇。比较高校高很多。具体是研一1700，研二以后2500-3000。此外，五一、十一、元旦各有1000的过节费。交的学费2个月以后以奖学金的名义返还。<br>4、生活。每周都有所里组织的羽毛球、乒乓球、游泳活动，所以不用担心生活枯燥。<br>5、假期。周末双休，放假很规律。暑假三周，寒假三周。不像大学一样，看导师的心情。<br>6、 建议。研究生跟导师之间是合作关系，不是单纯的培养关系。所以要考虑好自己的想法和导师方向不一致时候该怎么办。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;兰大15min计算机专硕调剂面试&quot;&gt;&lt;a href=&quot;#兰大15min计算机专硕调剂面试&quot; class=&quot;headerlink&quot; title=&quot;兰大15min计算机专硕调剂面试&quot;&gt;&lt;/a&gt;兰大15min计算机专硕调剂面试&lt;/h1&gt;&lt;p&gt;首先说老师们好，然后老师叫你</summary>
      
    
    
    
    <category term="20考研" scheme="https://sailvr.github.io/categories/20%E8%80%83%E7%A0%94/"/>
    
    
    <category term="20考研" scheme="https://sailvr.github.io/tags/20%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>校招应该掌握的java常识</title>
    <link href="https://sailvr.github.io/2020/03/07/java/"/>
    <id>https://sailvr.github.io/2020/03/07/java/</id>
    <published>2020-03-07T09:08:49.000Z</published>
    <updated>2020-05-26T03:23:01.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h3><p>Http报文层面：GET将请求信息放在URL中，POST放在报文体中</p><p>数据库层面：GET符合幂等性和安全性，POST不符合</p><p>其他层面：GET可以被缓存、被存储，而POST不行</p><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><p>Cookie是由服务器发给客户端的特殊消息，以文本的形式存放在客户端。客户端发送请求的时候，会把Cookie回发。服务器接收到后，会解析Cookie生成与客户端相对应的内容。</p><p>Session：服务器端的机制，在服务器上保存的信息、解析客户端请求并操作session id，按需保存状态信息。</p><p>Session的实现：1使用Cookie实现 2使用URL回写来实现</p><p>区别:Cookie数据存放在客户的浏览器上，Session数据放在服务器上。Session相对于Cookie更安全。若减轻服务器负担，应当使用Cookie</p><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><p>SSL（Security Sockets Layer 安全套阶层）</p><p>为网络通信提供安全及数据完整性的一种安全协议</p><p>是操作系统对外的API，SSL3.0后更名为TLS</p><p>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p><p><strong>加密的方式</strong> </p><p>对称加密：加密和解密都使用同一个密钥</p><p>非对称加密：加密使用的密钥和解密使用的密钥是不相同的</p><p><strong>HTTPS数据传输流程</strong></p><p>浏览器将支持的加密算法信息发送给服务器</p><p>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</p><p>浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器</p><p>服务器使用私钥解密信息，验证哈希，加密相应信息回发浏览器</p><p>浏览器解密响应信息，并对消息进行验真，之后进行加密交互数据</p><p><strong>区别</strong></p><p>HTTPS需要到CA申请证书，HTTP不需要</p><p>HTTPS密文传输，HTTP明文传输</p><p>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</p><p>HTTPS = HTTP+加密+认证+完整性保护，较HTTP安全</p><p><strong>HTTPS真的很安全吗？</strong></p><p>浏览器默认填充http://，请求需要进行跳转，有被劫持的风险</p><p>可以使用HSTS（HTTP Strict Transport Security）优化</p><h3 id="Socket相关"><a href="#Socket相关" class="headerlink" title="Socket相关"></a>Socket相关</h3><p><strong>Socket简介</strong></p><p>Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h3><ul><li>二叉查找树</li><li>B-树</li><li>B+树</li><li>Hash结构</li></ul><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h3><ul><li>根节点至少包括俩个孩子</li><li>树中每个节点最多含有m个孩子（m&gt;=2）</li><li>除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子</li><li>所有叶子节点都在同一层</li><li>假设每个非终端节点中包含有n个关键字信息，其中</li><li><ul><li>Ki（i=1,2….n）为关键字，且关键字按顺序升序排序K(i-1)&lt;Ki</li><li>关键字的个数n必须满足：ceil(m/2)-1&lt;=n&lt;=m-1</li><li>非叶子节点的指针：P[1],P[2],…P[M]；其中P[1]只想关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其中P[i]指向关键字属于(K[i-1],K[i])的子树</li></ul></li></ul><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+ Tree"></a>B+ Tree</h3><p>B+树定义基本与B树相同，除了</p><ul><li>非叶子节点的子树指针与关键字个数相同</li><li>非叶子节点的子树指针P[i]，只想关键字值(K[i],K[i+1])的子树</li><li>非叶子节点仅用来索引，数据都保存在叶子节点中</li><li>所有叶子节点均有一个链指针指向下一个叶子节点</li></ul><p>B+ Tree更适合用来做存储索引</p><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更有利于对数据库的扫描</li></ul><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>缺点</p><ul><li>仅仅能满足“=”，“IN”，不能使用范围查询</li><li>无法被用来避免数据的排序操作</li><li>不能利用部分索引键查询</li><li>不能避免表扫描</li><li>遇到大量Hash值相等的情况后性能并不一定就会比B Tree高</li></ul><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>32位机器上的自然数一共有4294967296个，如果用一个bit来存放一个整数，1代表存在，0代表不存在，那么把全部自然数存储在内存只要4294967296 / (8 * 1024 * 1024) = 512MB（8bit = 一个字节），而这些自然数存放在文件中，一行一个数字，需要20G的容量。可见，bitmap算法节约了非常多的空间。</p><h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><ul><li>密集索引文件中的每个搜索码值都对应一个索引值</li><li>稀疏索引文件只为索引码的某些值建立索引项</li></ul><p>InnoDB</p><ul><li>若一个主键被定义，该主键则作为密集索引</li><li>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引</li><li>若不满足以上条件，innoDB内部会生成一个隐藏主键（密集索引）</li><li>若主键索引存储相关键位和其对应的主键值，包含俩次查找</li></ul><h3 id="索引调优"><a href="#索引调优" class="headerlink" title="索引调优"></a>索引调优</h3><ul><li>如何定位并优化慢查询Sql？</li><li><ul><li>根本慢日志定位慢查询sql</li><li>使用explain等工具分析sql</li><li>修改sql或者尽量让sql走索引</li></ul></li><li>联合索引的最左前缀匹配原则的成因</li><li><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul></li><li>索引建立越多越好吗？</li><li><ul><li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li><li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li><li>更多的索引意味着也需要更多的空间</li></ul></li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="缓存中间件——Memcache和Redis的区别"><a href="#缓存中间件——Memcache和Redis的区别" class="headerlink" title="缓存中间件——Memcache和Redis的区别"></a>缓存中间件——Memcache和Redis的区别</h3><p>Memcache：代码层类似Hash</p><ul><li>支持简单数据类型</li><li>不支持数据持久化存储</li><li>不支持主从</li><li>不支持分片</li></ul><p>Redis</p><ul><li>数据类型丰富</li><li>支持数据磁盘持久化存储</li><li>支持主从</li><li>支持分片</li></ul><h3 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h3><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程，单线程也能处理高并发请求，想多核也可启动多实例</li><li>使用多路I/O复用类型，非阻塞IO</li></ul><h3 id="多路I-O复用模型"><a href="#多路I-O复用模型" class="headerlink" title="多路I/O复用模型"></a>多路I/O复用模型</h3><p>Redis采用的I/O多路复用函数：epoll/kqueue/evport/select?</p><ul><li>因地制宜</li><li>优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现</li><li>以时间复杂度为O(n)的select作为保底</li><li>基于react设计模式监听I/O事件</li></ul><h3 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h3><p>供用户使用的数据类型</p><ul><li>String：最基本的数据类型，二进制安全</li><li>Hash：String元素组成的字典，适合用于存储对象</li><li>List：列表，按照String元素插入顺序排序</li><li>Set：String元素组成的无序结合，通过哈希表实现，不允许重复</li><li>Sorted Set：通过分数来为集合中的成员进行从小到大的排序</li><li>用于计数的HyperLogLog，用于支持存储地理位置信息的Geo</li></ul><h3 id="从海量Key里查询出某一固定前缀的Key"><a href="#从海量Key里查询出某一固定前缀的Key" class="headerlink" title="从海量Key里查询出某一固定前缀的Key"></a>从海量Key里查询出某一固定前缀的Key</h3><p>KEYS pattern：查找所有符合给定模式pattern的key</p><ul><li>KEYS指令一次性返回所有匹配的key</li><li>键的数量过大使服务卡顿</li></ul><p>从海量Key里查询出某一固定前缀的Key</p><ul><li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</li><li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</li><li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li><li>一次返回的数量不可控，只能是大概率符合count参数</li></ul><h3 id="如何通过Redis实现分布式锁"><a href="#如何通过Redis实现分布式锁" class="headerlink" title="如何通过Redis实现分布式锁"></a>如何通过Redis实现分布式锁</h3><p>分布式锁需要解决的问题</p><ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul><p>SETNX key value：如果key不存在，则创建并赋值</p><ul><li>时间复杂度 O(1)</li><li>返回值：设置成功，返回1；设置失败，则返回0</li></ul><p>如何解决SETNX长期有效的问题</p><ul><li>EXPIRE key seconds</li><li><ul><li>设置key的生存时间，当key过期时（生存时间为0），会被自动删除</li><li>缺点：原子性得不到满足</li></ul></li><li>SET key value**[EX seconds]**     <strong>[PX milliseconds]</strong>   <strong>[NX|XX]</strong> </li><li><ul><li>EX second：设置键的过期时间为second秒</li><li>PX millisecond：设置键的过期时间为millisecond毫秒</li><li>NX：只要键不存在时，才对键进行设置操作</li><li>XX：只要键已经存在时，才对键进行设置操作</li><li>SET操作成功完成时，返回OK，否则返回nil</li></ul></li></ul><p>集中过期，由于存在大量的key很耗时，会出现短暂的卡顿现象</p><ul><li>解决方案：在设置key的过期时间的时候，给每个key加上随机值</li></ul><h3 id="如何实现异步队列"><a href="#如何实现异步队列" class="headerlink" title="如何实现异步队列"></a>如何实现异步队列</h3><p>BLPOP：阻塞直到队列有消息或者超时</p><ul><li>缺点：只能供一个消费者消费</li></ul><p>pub/sub：主题订阅者模式</p><ul><li>发送者pub发送消息，订阅者sub接收消息</li><li>订阅者可以订阅任意数量的频道</li></ul><p>pub/sub的缺点</p><ul><li>消息的发布是无状态的，无法保证可达</li></ul><h3 id="Redis如何做持久化"><a href="#Redis如何做持久化" class="headerlink" title="Redis如何做持久化"></a>Redis如何做持久化</h3><h4 id="RDB（快照持久化）：保存某个时间点的全量数据快照"><a href="#RDB（快照持久化）：保存某个时间点的全量数据快照" class="headerlink" title="RDB（快照持久化）：保存某个时间点的全量数据快照"></a>RDB（快照持久化）：保存某个时间点的全量数据快照</h4><ul><li>SAVE：阻塞Redis的服务器进程，直到EDB文件被创建完毕</li><li>BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器的进程</li></ul><p>自动化触发RDB持久化的方式</p><ul><li>根据redis.com配置里的SAVE m n定时触发（用的是BGSAVE）</li><li>主从复制时，主节点自动触发</li><li>执行Debug Reload</li><li>执行Shutdown且没有开启AOF持久化</li></ul><p>BGSAVE原理</p><ul><li>系统调用fork():创建进程，实现了Copy-on-Write</li></ul><p>Copy-on-Write</p><ul><li>如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调试者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变</li></ul><p>RDB持久化缺点</p><ul><li>内存数据的全量同步，数据量大会由于I/O而严重影响性能</li><li>可能会因为Redis挂掉而丢失从当前至最近以一次快照期间的数据</li></ul><h4 id="AOF（Append-Only-File）持久化：保存写状态"><a href="#AOF（Append-Only-File）持久化：保存写状态" class="headerlink" title="AOF（Append-Only-File）持久化：保存写状态"></a>AOF（Append-Only-File）持久化：保存写状态</h4><ul><li>记录了除了查询以外的所有变更数据库状态的指令</li><li>以append的形式追加保存到AOF文件中（增量）</li></ul><p>日志重写解决AOF文件大小不断增大的问题，原理如下：</p><ul><li>调用fork()，创建一个子进程</li><li>子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件</li><li>主进程持续将新的变动同时写到内存和原来的AOF里</li><li>主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动</li><li>使用新的AOF文件替换掉旧的AOF文件</li></ul><p>RDB和AOF</p><ul><li>RDB优点：全量数据快照，文件小，恢复快</li><li>RDB缺点：无法保存最近一次快照之后的数据</li><li>AOF优点：可读性高，适合保存增量数据，数据不易丢失</li><li>AOF缺点：文件体积大，恢复时间长</li></ul><h4 id="RDB-AOF混合持久化方式"><a href="#RDB-AOF混合持久化方式" class="headerlink" title="RDB-AOF混合持久化方式"></a>RDB-AOF混合持久化方式</h4><ul><li>BGSAVE做镜像全量持久化，AOF做增量持久化</li></ul><h3 id="Pipeline及主从同步"><a href="#Pipeline及主从同步" class="headerlink" title="Pipeline及主从同步"></a>Pipeline及主从同步</h3><p>使用Pipeline的好处</p><ul><li>Pipeline和linux的管道类似</li><li>Redis基于请求/相应模型，单个请求处理需要一一应答</li><li>Pipeline批量执行指令，节省多次IO往返的时间</li><li>有顺序依赖的指令分批发送</li></ul><p>Redis的同步机制</p><ul><li>主从同步原理</li><li><ul><li><a href="https://blog.csdn.net/qq_41724691/article/details/86616266">原理</a></li></ul></li><li>全同步过程</li><li><ul><li>Slave发送sync命令到Master</li><li>Master启动一个后台进程，将Redis中的数据快照保存到文件中</li><li>Master将保存数据快照期间受到的写命令缓存起来</li><li>Master完成写文件操作后，将该文件发送给Slave</li><li>使用新的AOF文件替换掉旧的AOF文件</li><li>Master将这期间收集的增量写命令发送给Salve端</li></ul></li><li>增量同步过程</li><li><ul><li>Master接收到用户的操作指令，判断是否需要传播到Slave</li><li>将操作记录追加到AOF文件</li><li>将操作传播到其他Slave</li><li><ul><li>对齐主从库</li><li>往相应缓存写入指令</li></ul></li><li>将缓存中的数据发送给Slave</li></ul></li><li>Redis Sentinel</li><li><ul><li>解决主从同步Master宕机后的主从切换问题</li><li><ul><li>监控：检查主从服务器是否运行正常</li><li>提醒：通过API向管理员或者其他应用程序发送故障通知</li><li>自动故障迁移：主从切换</li></ul></li></ul></li><li>流言协议Gossip</li><li><ul><li>在杂乱无章中寻求一致</li><li><ul><li>每个节点都随机地与对方通信，最终所有节点的状态保持一致</li><li>种子节点定期随机向其他节点发送节点列表以及需要传播的信息</li><li>不保证信息一定会传递给所有节点，但是最终会趋于一致</li></ul></li></ul></li></ul><h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>如和从海量数据里找到所需？</p><ul><li>分片：按照某种规划去划分数据，分散存储在多个节点上</li><li>常规的按照哈希划分无法实现节点的动态增减</li></ul><p>Redis集群原理</p><ul><li>一致性哈希算法</li><li><ul><li>对2^32取模，将哈希值空间组织成虚拟的圆环</li><li>将数据key使用相同的函数Hash计算出哈希值</li></ul></li><li>引入虚拟节点解决数据倾斜的问题</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="Linux的体系结构"><a href="#Linux的体系结构" class="headerlink" title="Linux的体系结构"></a>Linux的体系结构</h3><ul><li>体系结构主要分为用户态（用户上层活动）和内核态</li><li>内核：本质是一段管理计算机硬件设备的程序</li><li>系统调用：内核的访问接口，是一种能再简化的操作</li><li>公用函数库：系统调用的组合拳</li><li>Shell：命令解释器，可编程</li></ul><h3 id="查找特定的文件"><a href="#查找特定的文件" class="headerlink" title="查找特定的文件"></a>查找特定的文件</h3><p>find</p><ul><li>作用：在指定目录下查找文件</li></ul><p>面试里常用的方式</p><ul><li>find ~ -name “target3.java” 精确查找文件</li><li>find ~ -name “target” 模糊查找文件</li><li>find ~ -iname “target*” 不区分文件名大小写去查找文件</li><li>man find：更多关于find指令的使用说明</li></ul><h3 id="检索文件的内容"><a href="#检索文件的内容" class="headerlink" title="检索文件的内容"></a>检索文件的内容</h3><p>grep</p><ul><li>全称：Global Regular Expression Print</li><li>作用：查找文件里符合条件的字符串</li></ul><p>管道操作符</p><ul><li>可将指令链接起来，前一个指令的输出作为后一个指令的输入</li></ul><p>使用管道注意的要点</p><ul><li>只处理一个命令正确输出，不处理错误输出</li><li>右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃</li><li>sed，awk，grep，cut，head，top，less，more，wc，join，sort，split等</li></ul><h3 id="对文件内容做统计"><a href="#对文件内容做统计" class="headerlink" title="对文件内容做统计"></a>对文件内容做统计</h3><p>awk</p><ul><li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分</li><li>将切片直接保存在内建的变量中，$1,$2…($0表示行的全部)</li><li>支持对单个切片的判断，支持循环判断，默认分隔符为空格</li></ul><h3 id="批量替换文件内容"><a href="#批量替换文件内容" class="headerlink" title="批量替换文件内容"></a>批量替换文件内容</h3><p>sed</p><ul><li>全名stream editor 流编辑器</li><li>适合对文本的行内容进行处理</li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="谈谈你对java的理解"><a href="#谈谈你对java的理解" class="headerlink" title="谈谈你对java的理解"></a>谈谈你对java的理解</h3><ul><li>平台无关行</li><li>GC（垃圾回收机制）</li><li>语言特性（泛型，反射等）</li><li>面向对象</li><li>类库</li><li>异常处理</li></ul><h3 id="Compile-Once-Run-Anywhere如何实现"><a href="#Compile-Once-Run-Anywhere如何实现" class="headerlink" title="Compile Once ,Run Anywhere如何实现"></a>Compile Once ,Run Anywhere如何实现</h3><p>javap -c对代码进行反汇编</p><p>Javac编译，生成字节码；JVM解析，转换成特定平台的执行指令</p><p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台是运行不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。</p><p>问：为什么JVM不直接把源码解析成机器码去执行？</p><ul><li>准备工作：每次执行都需要各种检查</li><li>兼容性：也可以将别的语言解析成字节码</li></ul><h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><p>Java虚拟机</p><ul><li>Class Loader：依据特定格式，加载class文件到内存</li><li>Execution Engine：对命令进行解析</li><li>Native Interface：融合不同开发语言的原生库为Java所用</li><li>Runtime Data Area：JVM内存空间结构模型</li></ul><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Robot.java</span></span><br><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String helloSentence)</span></span>&#123;</span><br><span class="line">        System.out.println(helloSentence+<span class="string">&quot; &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">throwHello</span><span class="params">(String tag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> + tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReflectSample.java</span></span><br><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class rc = Class.forName(<span class="string">&quot;reflect.Robot&quot;</span>);</span><br><span class="line">        Robot r = (Robot) rc.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name is &quot;</span> + rc.getName());</span><br><span class="line">        r.sayHi(<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        Method getHello = rc.getDeclaredMethod(<span class="string">&quot;throwHello&quot;</span>, String.class);</span><br><span class="line">        getHello.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object str = getHello.invoke(r, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;getHello result is &quot;</span>+ str);</span><br><span class="line"></span><br><span class="line">        Method sayHi = rc.getDeclaredMethod(<span class="string">&quot;sayHi&quot;</span>, String.class);</span><br><span class="line">        sayHi.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field name = rc.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(r, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        sayHi.invoke(r, <span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Class name is reflect.Robot</span><br><span class="line">bob <span class="keyword">null</span></span><br><span class="line">getHello result is HelloBob</span><br><span class="line">Welcome Alice</span><br></pre></td></tr></table></figure></div><h3 id="谈谈ClassLoader"><a href="#谈谈ClassLoader" class="headerlink" title="谈谈ClassLoader"></a>谈谈ClassLoader</h3><p>类从编译到执行的过程</p><ul><li>编译器将Robot.java源文件编译为Robot.class字节码文件</li><li>ClassLoader将字节码转换为JVM中的Class<robot>对象</robot></li><li>JVM利用Class<robot>对象实例化为Robot对象</robot></li></ul><p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class的二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。</p><p>ClassLoader的种类</p><ul><li>BootStrapClassLoader：C++编写，加载和辛苦java.*</li><li>ExtClassLoader：Java编写，加载扩展库javax.*</li><li>AppClassLoader：Java编写，加载程序所在目录</li><li>自定义ClassLoader：Java编写，定制化加载</li></ul><h3 id="谈谈类加载器的双亲委派机制"><a href="#谈谈类加载器的双亲委派机制" class="headerlink" title="谈谈类加载器的双亲委派机制"></a>谈谈类加载器的双亲委派机制</h3><p><a href="https://blog.csdn.net/yan245294305/article/details/86777503">https://blog.csdn.net/yan245294305/article/details/86777503</a></p><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><ul><li>隐式加载：new</li><li>显式加载：loadClass，forName等</li></ul><p>loadClass和forName的区别</p><p>类的装载过程</p><ul><li>加载：通过ClassLoader加载class文件字节码，生成Class对象</li><li>链接</li><li><ul><li>校验：检查加载的class的正确性和安全性</li><li>准备：为类变量分配存储空间并设置类变量初始值</li><li>解析：JVM将变量池内的符号引用转换为直接引用</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ul><p>loadClass和forName的区别</p><ul><li>Class.forName得到的class是已经初始化完成的</li><li>ClassLoader.loadClass得到的class是还没有链接的</li></ul><h3 id="Java的内存模型"><a href="#Java的内存模型" class="headerlink" title="Java的内存模型"></a>Java的内存模型</h3><p>JVM内存模型——JDK8</p><ul><li>线程私有：程序计数器，虚拟机栈，本地方法栈</li><li>线程共享：MetaSpace、Java堆</li></ul><p>程序计数器</p><ul><li>当前进程所执行的字节码行号指示器（逻辑）</li><li>改变计数器的值来选取下一条需要执行的字节码指令</li><li>和线程是一对一的关系即“线程私有”</li><li>对Java方法计数，如果是Native方法则计数器值为Undefined</li><li>不会发生内存泄漏</li></ul><p>Java虚拟机栈（Stack）</p><ul><li>Java方法执行的内存模型</li><li>包含多个栈帧（局部变量表，操作数栈，动态链接，返回地址）</li></ul><p>局部变量表和操作数栈</p><ul><li>局部变量表：包含方法执行过程中的所有变量</li><li>操作数栈：入栈，出栈，复制，交换，产生消费变量 </li></ul><p>递归为什么会引发java.lang.StackOverflowError异常</p><ul><li>递归过深，栈帧数超出虚拟栈深度</li></ul><p>本地方法栈</p><ul><li>与虚拟机栈相似，主要作用于标注了native方法</li></ul><p>元空间MetaSpace与永久代PermGen的区别</p><ul><li>元空间使用本地内存，而永久代使用的是jvm的内存</li></ul><p>MetaSpace相比PermGen的优势</p><ul><li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会为GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM如Jrockit集成</li></ul><p>Java堆（Heap）</p><ul><li>对象实例的分配区域</li><li>GC管理的主要区域</li></ul><h3 id="常考题解析"><a href="#常考题解析" class="headerlink" title="常考题解析"></a>常考题解析</h3><p>JVM三大性能调优参数 -Xms -Xmx -Xss的含义</p><ul><li>-Xms：规定了每个线程虚拟机栈（堆栈）的大小</li><li>-Xms：堆的初始值</li><li>-Xmx：堆能够达到的最大值</li></ul><p>Java内存模型中堆和栈的区别——内存分配策略</p><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间要求</li><li>栈式存储：数据区要求在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li></ul><p>Java内存模型中堆和栈的区别</p><ul><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比堆小</li><li>碎片相关：堆产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ul><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h3 id="垃圾回收之标记算法"><a href="#垃圾回收之标记算法" class="headerlink" title="垃圾回收之标记算法"></a>垃圾回收之标记算法</h3><p>对象被判定为垃圾的标准</p><ul><li>没有被其他对象引用</li><li><ul><li>引用计数算法</li><li>可达性分析算法</li></ul></li></ul><p>引用计数算法</p><ul><li>通过判断对象的引用数量来决定对象是否可以被回收</li><li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li><li>任何引用计数为0的对象可以被当做垃圾收集</li><li>优点：执行效率高，程序执行受影响较小</li><li>缺点：无法检测出循环引用的情况，导致内存泄漏</li></ul><p>可达性分析算法</p><ul><li>通过判断对象的引用链是否可达来决定对象是否可以被回收</li><li>可以作为GC Root的对象</li><li><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>方法区中的常量引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>本地方法栈中JNI（Native方法）的引用对象</li><li>活跃线程的引用对象</li></ul></li></ul><h3 id="谈谈你了解的垃圾回收算法"><a href="#谈谈你了解的垃圾回收算法" class="headerlink" title="谈谈你了解的垃圾回收算法"></a>谈谈你了解的垃圾回收算法</h3><p>标记-清楚算法（Mark and Sweep）（缺点：碎片化）</p><ul><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</li></ul><p>复制算法（Copying）</p><ul><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>存活的对象被从对象面复制到空闲面</li><li>将对象面所有对象内存清除</li><li>优点：</li><li><ul><li>解决碎片化问题</li><li>顺序分配内存，简单高效</li><li>适用于对象<strong>存活率低</strong>的场景</li></ul></li></ul><p>标记-整理算法（Compacting）</p><ul><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。</li><li>优点</li><li><ul><li>避免内存的不连续性</li><li>不用设置俩块内存互换</li><li>适用于<strong>存活率高</strong>的场景</li></ul></li></ul><p>分代收集算法（Generational Collector）</p><ul><li>垃圾回收算法的组合拳</li><li>按照对象生命周期的不同划分趋于以采用不用的垃圾回收算法</li><li>目的：提高JVM的回收效率</li></ul><p>GC的分类</p><ul><li>Minor GC</li><li>Full GC</li></ul><p>年轻代：尽可能快速地收集掉那些生命周期短的对象</p><ul><li>Eden区</li><li>两个Survivor区</li></ul><p>对象如何晋升到老年代</p><ul><li>经历一定Minor次数依然存活的对象</li><li>Survivor区中存活不下的对象</li><li>新生成的大对象（-XX：+PretenuerSizeThreshold）</li></ul><p>常用的调优参数</p><ul><li>-XX：SurvivorRatio：Eden和Survivor的比值i，默认8:1</li><li>-XX：NewRatio：老年代和年轻代内存大小的比例</li><li>-XX：MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值</li></ul><p>老年代：存放生命周期较长的对象</p><ul><li>标记-清理算法</li><li>标记-整理算法</li></ul><p>老年代</p><ul><li>Full GC和Major GC</li><li>Full GC比Minor GC慢，但执行频率低</li></ul><p>触发Full GC的条件</p><ul><li>老年代空间不足</li><li>永久代空间不足</li><li>CMS GC时出现promotion failed，concurrrent mode failure</li><li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li><li>调用System.gc()</li><li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li></ul><h3 id="分带收集算法（Generational-Collector）"><a href="#分带收集算法（Generational-Collector）" class="headerlink" title="分带收集算法（Generational Collector）"></a>分带收集算法（Generational Collector）</h3><p>Stop-the-World</p><ul><li>JVM由于要执行GC而停止了应用程序的执行</li><li>任何一种GC算法中都会发生</li><li>多数GC优化通过减少Stop-the-world发生的时间来提高程序性能</li></ul><p>Safepoint</p><ul><li>分析过程中对象引用关系不会发生变化的点</li><li>产生Safepoint的地方：方法调用；循环跳转；异常跳转等</li><li>安全点数量得时钟</li></ul><h3 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h3><p>JVM的运行模式</p><ul><li>Server</li><li>Client</li></ul><p><strong>年轻代常见的垃圾收集器</strong></p><p>Serial收集器(-XX:+UseSerialGC,复制算法)</p><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的年轻代收集器</li></ul><p>ParNew收集器（-XX：+UseParNewGC，复制算法）</p><ul><li>多线程收集，其余的行为、特点和Serial收集器一样</li><li>单核执行效率不如Serial，在多核下执行才有优势</li></ul><p>Parallel Scavenge（-XX：+UseParallelGC，复制算法）</p><ul><li>吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li><li>比起关注用户线程停顿时间，更关注系统的吞吐量</li><li>在多核下执行才有优势，Server模式下默认的年轻代收集器</li></ul><p><strong>老年代常见的垃圾收集器</strong></p><p>Serial Old收集器（-XX：+UseSerialOldGC，标记-整理算法）</p><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作进程</li><li>简单高效，Client模式下默认的老年代收集器</li></ul><p>Parallel Old收集器（-XX：+UseParallelGC，标记-整理算法）</p><ul><li>多线程，吞吐量优先</li></ul><p>CMS收集器（-XX：+UseConcMarkSweepGC，标记-清除算法）</p><ul><li>初始标记：stop-the-world</li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的现象</li><li>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置CMS收集器的数据结构</li></ul><p>G1收集器（-XX：+UseG1GC，复制+标记-整理算法）</p><p>Garbage First收集器的特点</p><ul><li>并行和并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>Garbage First收集器</p><ul><li>将整个Java堆内存划分成多个大小相等的Region</li><li>年轻代和老年代不再物理隔离</li></ul><h3 id="GC相关的面试题"><a href="#GC相关的面试题" class="headerlink" title="GC相关的面试题"></a>GC相关的面试题</h3><p>Object的finalize()方法的作用是否与C++的析构函数作用相同</p><ul><li>与C++的析构函数不同，析构函数调用确定，而它的是不确定的</li><li>将未被引用的对象放置于F-Queue队列</li><li>方法执行随时可能会被终止</li><li>给予对象最后一次重生的机会</li></ul><p>Java中的强引用，软引用，弱引用，虚引用有什么用</p><ul><li>强引用（Strong Reference）</li><li><ul><li>最普遍的引用：Object obj = new Object()</li><li>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</li><li>通过将对象设置为null来弱化引用，使其被回收</li></ul></li><li>软引用（Soft Reference）</li><li><ul><li>对象处在游泳但非必须的状态</li><li>只有当内存空间不足时，GC会回收该引用的对象的内存</li><li>可以用来实现高速缓存</li></ul></li><li>弱引用（Weak Reference）</li><li><ul><li>非必须的对象，比软引用更弱一些</li><li>GC时会被回</li><li>被回收的概率也不大，因为GC线程优先级比较低</li><li>适用于引用偶尔被使用且不影响垃圾收集的对象</li></ul></li><li>虚引用（PhantomReference）</li><li><ul><li>不会决定对象的声明周期</li><li>任何时候都可以被垃圾收集器回收</li><li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li><li>必须和引用队列ReferenceQueue联合使用</li></ul></li></ul><p>引用队列（Reference Queue）</p><ul><li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达</li><li>存储关联的且被GC的软引用，弱引用以及虚引用</li></ul><h1 id="java多线程与并发"><a href="#java多线程与并发" class="headerlink" title="java多线程与并发"></a>java多线程与并发</h1><h3 id="start和run方法的区别"><a href="#start和run方法的区别" class="headerlink" title="start和run方法的区别"></a>start和run方法的区别</h3><ul><li>调用start()方法会创建一个新的子线程并启动</li><li>run()方法只是Thread的一个普通方法的调用</li></ul><h3 id="Thread和Runnable是什么关系"><a href="#Thread和Runnable是什么关系" class="headerlink" title="Thread和Runnable是什么关系"></a>Thread和Runnable是什么关系</h3><ul><li>Thread是实现Runnable接口的类，使得run支持多线程</li><li>因类的单一继承原则，推荐多使用Runnable接口</li></ul><h3 id="如何给run-方法传参"><a href="#如何给run-方法传参" class="headerlink" title="如何给run()方法传参"></a>如何给run()方法传参</h3><ul><li>构造函数</li><li>成员变量</li><li>回调函数</li></ul><h3 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h3><ul><li>主线程等待法</li><li>使用Thread类的join()阻塞当前进程以等待子线程处理完毕</li><li>通过Callable接口实现：通过FutureTask Or线程池获取</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul><li>新建New</li><li>运行Runnable</li><li>无限期等待Waiting</li><li>限期等待Timed Waiting</li><li>阻塞Blocked</li><li>结束Terminated</li></ul><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul><li>sleep是Thread类的方法，wait是Object类的方法</li><li>sleep()方法可以在任何地方使用</li><li>wait()方法只能在synchronized方法或synchronized块中使用</li></ul><p><strong>最本质的区别</strong></p><ul><li>Thread.sleep只会让出CPU，不会导致锁行为的改变(不会让出锁)</li><li>Object.wait不仅让出CPU，还会释放已经占有的同步资源锁</li></ul><h3 id="yield函数"><a href="#yield函数" class="headerlink" title="yield函数"></a>yield函数</h3><ul><li>当调用Thread.yield()函数，会给线程调度器一个当前进程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示</li></ul><h3 id="interrupt函数"><a href="#interrupt函数" class="headerlink" title="interrupt函数"></a>interrupt函数</h3><p><strong>如何中断线程</strong></p><p>调用interrupt()，通知线程应该中断了</p><ul><li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常</li><li>如果线程处于正常活动状态，那么会将线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响</li></ul><h1 id="java多线程与并发原理"><a href="#java多线程与并发原理" class="headerlink" title="java多线程与并发原理"></a>java多线程与并发原理</h1><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>Monitor:每个java对象天生自带了一把看不见的锁</p></blockquote><blockquote><p>重入：从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入</p></blockquote><blockquote><p>自旋锁：1 许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得</p><p>2 通过让线程执行忙循环等待锁的释放，不让出CPU</p><p>缺点:若锁被其他线程长时间占用，会带来许多性能上的开销</p></blockquote><blockquote><p>自适应自旋锁：1 自旋的次数不再固定</p><p>2 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</p></blockquote><blockquote><p>锁消除：更彻底的优化</p></blockquote><blockquote><p>锁粗化：另一种极端</p></blockquote><blockquote><p>synchronized的四种状态：无锁，偏向锁，轻量级锁，重量级锁</p><p>锁膨胀方向：无锁→偏向锁→轻量级锁→重量级锁</p></blockquote><blockquote><p>偏向锁:减少同一线程获得锁的代价</p><ul><li>大多数情况下，锁不存在多线程竞争，总是由同一个线程多次获得</li></ul><p>锁的内存语义：当线程释放锁时，java内存模型会把该线程对应的本地内存中的共享变量刷新到主内存中；</p><p>而当线程获取锁时，Java内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p></blockquote><h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><blockquote><p>ReentrantLock(再入锁)</p><ul><li>位于java.util.concurrent.locks包</li><li>和CountDownLatch、FutureTask、Samaphore一样基于AQS实现</li><li>能够实现 比synchronized更细粒度的控制，如控制fairness</li><li>调用lock()之后，必须调用unlock()释放锁</li><li>性能未必比synchronized高，并且也是可重入的</li></ul></blockquote><blockquote><p>ReentrantLock公平性的设置</p><ul><li>RentrantLock faiLock = new ReentrantLock(true);</li><li>参数为true时，倾向于将锁赋予等待时间最久的线程</li><li>公平锁：获取锁的顺序按先后调用lock方法的顺序（慎用）</li><li>非公平锁：抢占的顺序不一定，看运气</li><li>synchronized是非公平锁</li></ul></blockquote><blockquote><p><strong><em>区别</em></strong></p><p>ReentrantLock将锁对象化</p><ul><li>判断是否有线程，或者某个特定线程，在排队等待获取锁</li><li>带超时的获取锁的尝试</li><li>感知有没有成功获取锁</li></ul></blockquote><h3 id="什么是Java内存模型中的happens-before"><a href="#什么是Java内存模型中的happens-before" class="headerlink" title="什么是Java内存模型中的happens-before"></a>什么是Java内存模型中的happens-before</h3><blockquote><p>Java内存模型JMM</p><p>本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实力字段，静态字段和构成数组对象的元素）的访问方式。</p></blockquote><blockquote><p>JMM与Java内存区域划分是不同的概念层次</p><ul><li>JMM描述的是一组规则，围绕原子性，有序性，可见性展开</li><li>相似点：存在共享区域和私有区域</li></ul></blockquote><blockquote><p>主内存与工作内存的数据存储类型以及操作方式归纳</p><ul><li>方法里的基本数据类型本地变量将直接存储在工作内存的帧栈结构中</li><li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li>成员变量，static变量，类信息均会存储在主内存中</li><li>主内存共享的方式是线程各拷贝一份数据到工作内存中，操作完成后刷新回主内存</li></ul></blockquote><h3 id="JMM如何解决可见性问题"><a href="#JMM如何解决可见性问题" class="headerlink" title="JMM如何解决可见性问题"></a>JMM如何解决可见性问题</h3><blockquote><p><em>指令重排序需要满足的条件</em></p><ul><li>在单线程环境下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li></ul><p>无法通过happens-before原则推导出来的，才能进行指令的重排序</p><p>A操作的结果需要对B操作可见，则A和B存在happens-before关系</p></blockquote><blockquote><p>volatile:JVM提供的轻量级同步机制</p><ul><li>保证被volatile修饰的共享变量对所有线程总是可见的</li><li>禁止指令重排序优化</li></ul><p>volatile变量为何立即可见？</p><ul><li>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中</li><li>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效</li></ul><p>volatile如何禁止重排优化？</p><ul><li>内存屏障（Memory Barrier）</li><li><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ul></li><li>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化</li><li>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本</li></ul></blockquote><blockquote><p>volatile和synchronized的区别</p><ul><li>volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法和类级别</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量修改的可见性和原子性</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li></ul></blockquote><h3 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare and Swap）"></a>CAS（Compare and Swap）</h3><blockquote><p>一种高效实现线程安全性的方法</p><ul><li>支持原子更细操作，适用于计数器，序列发生器等场景</li><li>属于乐观锁机制，号称lock-free</li><li>CAS操作失败时由开发者决定是继续尝试，还是执行别的操作</li></ul><p>CAS思想</p><ul><li>包含三个操作数——内存位置（V）、预期原值（A）和新值（B）</li></ul><p>CAS多数情况下对开发者来说是透明的</p><ul><li>J.U.C的atomic包提供了常用的原子性数据类型以及引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选</li><li>Unsafe类虽提供了CAS服务，但因能够操纵任意内存地址读写而有隐患</li><li>Java9以后，可以使用Variable Handle API来替代Unsafe</li></ul><p>缺点</p><ul><li>若循环时间长，则开销很大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题 解决：AtomicStampedReference</li></ul></blockquote><h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><blockquote><p>利用Executors创建不用的线程池满足不同场景的需求</p></blockquote><blockquote><p>Fork/Join框架</p><ul><li>把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大人物结果的框架</li></ul><p>为什么要使用线程池</p><ul><li>降低资源消耗</li><li>提高线程的可管理性</li></ul></blockquote><blockquote><p>J.U.C的三个Executor接口</p><ul><li>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</li><li>ExecutorService:具备管理执行器和任务生命周期的方法，提交任务机制更完善</li><li>ScheduleExecutorService：支持Future和定期执行任务</li></ul></blockquote><blockquote><p>ThreadPoolExecutor的构造函数</p><ul><li>corePoolSize：核心线程数量</li><li>maximumPoolSize：线程不够用时创建的最大线程数</li><li>workQueue：任务等待队列</li><li>keepAliveTime：抢占的顺序不一定，看运气</li></ul></blockquote><blockquote><p>线程池的状态</p><ul><li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务</li><li>SHUTDOWN：不再接受新提交的任务，但可以处理存量任务</li><li>STOP：不再接受新提交的任务，也不处理存量任务</li><li>TIDYING：所有的任务都已终止</li><li>TERMINATED：terminated（）方法执行完后进入该状态</li></ul></blockquote><blockquote><p>线程池的大小如何选定</p><ul><li>CPU密集型：线程数 = 按照核数或者核数+1设定</li><li>I/O密集型：线程数*（1+平均等待时间/平均工作时间）</li></ul></blockquote><h1 id="常见类库与技巧"><a href="#常见类库与技巧" class="headerlink" title="常见类库与技巧"></a>常见类库与技巧</h1><h3 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h3><blockquote><p>Error和Exception的区别</p><ul><li>Error：程序无法处理的系统错误，编译器不做检查</li><li>Exception：程序无法处理的异常，捕获后可能恢复</li><li>总结：前者是程序无法处理的错误，后者是可以处理的异常</li></ul></blockquote><blockquote><p>Exception</p><ul><li>RuntimeException：不可预知，程序应当自行避免</li><li>非RuntimeException：可预知的，从编译器检验的异常</li></ul></blockquote><h3 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h3><blockquote><ul><li>抛出异常：创建异常对象，交由运行时系统处理</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li></ul></blockquote><blockquote><p>异常的处理原则</p><ul><li>具体明确：抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因</li><li>提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题</li><li>延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常。</li></ul></blockquote><blockquote><p>在用户看来，应用系统发生的所有异常都是应用系统内部的异常</p><ul><li>设计一个通用的继承自RuntimeException的异常来统一处理</li><li>其余异常都统一转译为上述异常AppException</li><li>在catch之后，抛出上述异类的子类，并提供足以定位的信息</li><li>由前端接收APPException做统一处理</li></ul></blockquote><blockquote><p>Java异常处理性能的地方</p><ul><li>try-catch块影响JVM的优化</li><li>异常对象实例需要保存栈快照等信息，开销较大</li></ul></blockquote><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><blockquote><p>List、Set、Map等</p></blockquote><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap、HashTable、ConccurentHashMap</p><blockquote><p>HashMap(Java8以前)：数组+链表；（Java8及以后）数组+链表+红黑树</p><p>性能从O（n）提高到O（logn）</p><p>HashMap：如何有效减少碰撞</p><ul><li>扰动函数：促使元素位置分布均匀，减少碰撞机率</li><li>使用final对象，并采用合适的equals()和hashCode()方法</li></ul><p>HashMap：扩容的问题</p><ul><li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li><li>rehashing是一个比较耗时的过程</li></ul></blockquote><blockquote><p>如何优化HashTABLE？</p><ul><li>通过锁细粒度化，将整锁拆解成多个锁进行优化</li></ul></blockquote><blockquote><p>三者的区别</p><ul><li>HashMap线程不安全，数组+链表+红黑树</li><li>HashTable线程安全，锁住整个对象，数组+链表</li><li>ConccurentHashMap线程安全，CAS+同步锁，数组+链表+红黑树</li><li>HashMap的key、value均可为null，而其他的俩个类不支持</li></ul></blockquote><h3 id="J-U-C知识点梳理"><a href="#J-U-C知识点梳理" class="headerlink" title="J.U.C知识点梳理"></a>J.U.C知识点梳理</h3><blockquote><p>java.util.concurrent:提供了并发编程的解决方案</p><ul><li>CAS是java.util.concurrent.atomic包的基础</li><li>AQS是java.util.concurrent.locks包以及一些常用类比如Semophore，ReentrantLock等类的基础</li></ul></blockquote><blockquote><p>J.U.C包的分类</p><ul><li>线程执行器executor</li><li>锁locks</li><li>原子变量类atomic</li><li>并发工具类tools</li><li>并发集合collections</li></ul></blockquote><blockquote><p>并发工具类</p><ul><li>闭锁 CountDownLatch</li><li>栅栏 CyclicBarrier</li><li>信号量 Semaphore</li><li>交换器 Exchanger</li></ul></blockquote><blockquote><p>CountDownLatch：让主线程等待一组事件发生后继续执行</p><ul><li>事件指的是CountDownLatch里的countDown()方法</li></ul></blockquote><blockquote><p>CyclicBarrier:阻塞当前线程，等待其他线程</p><ul><li>等待其他线程，且会阻塞自己当前线程，所有线程必须同时到达栅栏位置后，才会继续执行</li><li>所有线程到达栅栏处，可以触发执行另外一个预先设置的线程</li></ul></blockquote><blockquote><p>Semaphore：控制某个资源可被同时访问的线程个数</p></blockquote><blockquote><p>Exchanger：俩个线程到达同步点后，相互交换数据</p></blockquote><blockquote><p>BlockingQueue：提供可阻塞的入队和出队操作</p><p>主要用于生产者-消费者模式，在多线程场景时生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够达到将添加任务的生产和消费进行隔离的目的</p><ol><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>PrioriyuBlockingQueue</li><li>DealyQueue</li><li>SynchronousQueue</li><li>LinkedTransferQueue</li><li>LinkedBlockingDeque</li></ol></blockquote><h3 id="Java的IO机制"><a href="#Java的IO机制" class="headerlink" title="Java的IO机制"></a>Java的IO机制</h3><blockquote><p>NonBlock-IO：构建多路复用的、同步非阻塞的IO操作</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>NIO-Channels</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>NIO-Buffers</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li><li>MappedByteBuffer</li></ul></blockquote><blockquote><p>select、poll、epoll区别：略</p></blockquote><blockquote><p>Asynchronous IO：基于事件和回调机制</p><p>AIO如何进一步加工处理结果</p><ul><li>基于回调：实现CompletionHandler接口，调用时触发回调函数</li><li>返回Future：通过isDone()查看是否准备好，通过get()等待返回数据</li></ul></blockquote><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="IOC-（Inversion-of-control）-控制反转"><a href="#IOC-（Inversion-of-control）-控制反转" class="headerlink" title="IOC （Inversion of control） 控制反转"></a>IOC （Inversion of control） 控制反转</h3><blockquote><p>IOC容器的优势</p><ul><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要了解其中的细节</li></ul></blockquote><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><blockquote><p>Spring IOC支持的功能</p><ul><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调方法</li></ul></blockquote><blockquote><p>ApplicationContext的功能（继承多个接口）</p><ul><li>BeanFactory：能够管理、装配多个Bean</li><li>ResourcePatternResolver：能够加载资源文件</li><li>MessageSource：能够实现国际化等功能</li><li>ApplicationEventPublisher：能够注册监听器，实现监听机制</li></ul></blockquote><h3 id="getBean方法解析"><a href="#getBean方法解析" class="headerlink" title="getBean方法解析"></a>getBean方法解析</h3><blockquote><p>getBean方法的代码逻辑</p><ul><li>转换beanName</li><li>从缓存中加载实例</li><li>实例化Bean</li><li>检查parentBeanFactory</li><li>初始化依赖的Bean</li><li>创建Bean</li></ul></blockquote><blockquote><p>Spring Bean的作用域</p><ul><li>singleton：Spring的默认作用域，容器里拥有唯一的Bean实例</li><li>prototype：针对每个getBean请求，容器都会创建一个Bean实例</li><li>request：会为每个HTTP请求创建一个Bean实例</li><li>session：会为每个session创建一个Bean实例</li><li>globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效</li></ul></blockquote><blockquote><p>Bean的生命周期-销毁过程</p><ul><li>若实现了DisposableBean接口，则会调用destroy()方法</li><li>若配置了destroy-method属性，则会调用其配置的销毁方法</li></ul></blockquote><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><blockquote><p>关注点分离：不同的问题交给不同的部分去解决</p><ul><li>面向切面编程AOP正式此种技术的提现</li><li>通用功能化代码的实现，对应的就是所谓的切面Aspect</li><li>业务功能代码和切面代码分开后，架构将变得高内聚低耦合</li><li>确保功能的完整性：切面最终需要被合并到业务中Weave</li></ul></blockquote><blockquote><p>AOP的三种织入方式</p><ul><li>编译时织入：需要特殊的Java编译器，入AspectJ</li><li>类加载时织入：需要特殊的Java编译器，入AspectJ和AspectWerkz</li><li>运行时织入：Spring采用的方式，采用动态代理的方式，实现简单</li></ul></blockquote><blockquote><p>AOP的主要名词概念</p><ul><li>Aspect：通用功能的代码实现</li><li>Target：被织入Aspect的对象</li><li>Join Point：可以作为切入点的机会，所有方法都可以作为切入点</li><li>Pointcut：Aspect实际被应用在的Join Point，支持正则</li><li>Advice：类里的方法以及这个方法如何织入到目标方法的方式</li><li>Weaving：Aop的实现过程</li></ul></blockquote><blockquote><p>Advice的种类</p><ul><li>前置</li><li>后置</li><li>异常</li><li>最终</li><li>环绕</li></ul></blockquote><h3 id="Spring-AOP的原理"><a href="#Spring-AOP的原理" class="headerlink" title="Spring AOP的原理"></a>Spring AOP的原理</h3><blockquote><p>AOP的实现：JDKProxy和Cglib</p><ul><li>由AopProxyFactory根据AdvisedSupport对象的配置来决定</li><li>默认策略如果目标类是接口，则用JDKProxy来实现，否则用后者</li><li>JDKProxy的核心：InvocationHandler接口和Proxy类</li><li>Cglib：以继承的方式动态生成目标类的代理</li></ul></blockquote><blockquote><p>代理模式：接口+真实实现类+代理类</p></blockquote><blockquote><p>Spring里的代理模式的实现</p><ul><li>真实实现类的逻辑包含在了getBean方法里</li><li>getBean方法返回的实际上是Proxy的实例</li><li>Proxy实例是Spring采用JDK Proxy或CGLIB动态生成的、</li></ul></blockquote>]]></content>
    
    
    <summary type="html">java面试常见知识点</summary>
    
    
    
    <category term="校招" scheme="https://sailvr.github.io/categories/%E6%A0%A1%E6%8B%9B/"/>
    
    
    <category term="java interview" scheme="https://sailvr.github.io/tags/java-interview/"/>
    
  </entry>
  
</feed>
